# =========================
# MSG Attachment Collector (PDF + Images only)
# Notebook-safe (no argparse)
# =========================

from __future__ import annotations

import csv
import hashlib
import re
from datetime import datetime
from pathlib import Path

# --- OPTIONAL: install in notebook if needed ---
# !python -m pip install -U extract-msg

import extract_msg


# =========================
# CONFIG
# =========================

ROOT = Path(r"C:\Users\SHTANDO\Desktop\chatbot")   # <-- your project root
INPUT_DIR = ROOT / "input"                        # <-- put .msg files here
EXPORTS_DIR = ROOT / "_exports"                   # output base

# Which attachments to collect:
PDF_EXTS = {".pdf"}
IMG_EXTS = {".png", ".jpg", ".jpeg", ".tif", ".tiff", ".bmp", ".gif", ".webp"}

# If True: if same-content attachment appears again, we reuse the already-saved file
DEDUP_BY_CONTENT_HASH = True

# =========================
# HELPERS
# =========================

def now_stamp() -> str:
    return datetime.now().strftime("%Y%m%d_%H%M%S")

def safe_filename(name: str, max_len: int = 120) -> str:
    """
    Windows-safe filename: remove invalid chars, trim, keep extension.
    """
    name = (name or "").strip()
    name = re.sub(r'[<>:"/\\|?*\x00-\x1F]', "_", name)  # invalid on Windows
    name = re.sub(r"\s+", " ", name).strip()
    if len(name) <= max_len:
        return name
    # keep extension
    p = Path(name)
    stem = p.stem[: max_len - len(p.suffix) - 1]
    return f"{stem}_{p.suffix.lstrip('.')}".rstrip("_")

def sha256_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

def ensure_dir(p: Path) -> Path:
    p.mkdir(parents=True, exist_ok=True)
    return p

def msg_id_from_path(msg_path: Path) -> str:
    """
    Stable short ID from absolute path (not content).
    """
    h = hashlib.sha1(str(msg_path.resolve()).encode("utf-8", errors="ignore")).hexdigest()
    return h[:10]

def read_msg_attachments(msg_path: Path):
    """
    Yields tuples: (att_name, att_bytes)
    Works with extract-msg by saving to a temp dir is unreliable on Windows;
    so we read attachment data if available.
    """
    m = extract_msg.Message(str(msg_path))
    # Some versions need .close(); some use context mgmt; keep simple:
    m.process()  # parse
    # m.attachments may be list of Attachment objects
    for a in getattr(m, "attachments", []) or []:
        # attachment longFilename / shortFilename / filename vary by version
        fname = (
            getattr(a, "longFilename", None)
            or getattr(a, "shortFilename", None)
            or getattr(a, "filename", None)
            or "attachment"
        )
        # data property varies: .data or .rawData
        data = getattr(a, "data", None)
        if data is None:
            data = getattr(a, "rawData", None)
        # Some versions expose a "save" only; skip if we can't access bytes
        if data is None:
            # Try fallback: a.get_data() if present
            get_data = getattr(a, "get_data", None)
            if callable(get_data):
                data = get_data()
        if isinstance(data, str):
            # should not happen; ignore
            continue
        if not isinstance(data, (bytes, bytearray)):
            continue
        yield fname, bytes(data)

    try:
        m.close()
    except Exception:
        pass


# =========================
# MAIN
# =========================

def collect_pdf_and_images():
    run_dir = ensure_dir(EXPORTS_DIR / f"collect_att_{now_stamp()}")
    out_pdfs = ensure_dir(run_dir / "pdfs")
    out_imgs = ensure_dir(run_dir / "images")
    log_path = run_dir / "errors.log"
    manifest_path = run_dir / "manifest.csv"

    msg_files = sorted(INPUT_DIR.rglob("*.msg"))
    print("ROOT:", ROOT)
    print("INPUT_DIR:", INPUT_DIR)
    print("Found .msg files:", len(msg_files))
    print("RUN_DIR:", run_dir)

    # content-hash -> saved path (dedup)
    seen_hash = {}

    ok = 0
    fail = 0
    saved = 0

    with manifest_path.open("w", newline="", encoding="utf-8-sig") as f_csv, \
         log_path.open("w", encoding="utf-8") as f_log:
        w = csv.writer(f_csv, delimiter=";")
        w.writerow([
            "msg_file",
            "msg_id",
            "attachment_original_name",
            "attachment_ext",
            "sha256",
            "saved_path",
            "category"
        ])

        for msg_path in msg_files:
            mid = msg_id_from_path(msg_path)
            try:
                for att_name, att_bytes in read_msg_attachments(msg_path):
                    ext = Path(att_name).suffix.lower().strip()
                    if ext not in (PDF_EXTS | IMG_EXTS):
                        continue

                    h = sha256_bytes(att_bytes)

                    # Choose category folder
                    if ext in PDF_EXTS:
                        category = "pdf"
                        base_dir = out_pdfs
                    else:
                        category = "image"
                        base_dir = out_imgs

                    # Build short filename
                    clean_name = safe_filename(att_name if att_name else f"attachment{ext}")
                    # prefix with msg_id to keep traceability
                    # also include short hash prefix to avoid collisions
                    out_name = safe_filename(f"{mid}_{h[:8]}_{clean_name}", max_len=160)
                    out_path = base_dir / out_name

                    if DEDUP_BY_CONTENT_HASH and h in seen_hash:
                        # reuse earlier saved file
                        saved_path = seen_hash[h]
                    else:
                        out_path.write_bytes(att_bytes)
                        saved_path = out_path
                        if DEDUP_BY_CONTENT_HASH:
                            seen_hash[h] = str(saved_path)
                        saved += 1

                    w.writerow([
                        str(msg_path),
                        mid,
                        att_name,
                        ext,
                        h,
                        str(saved_path),
                        category
                    ])

                ok += 1

            except Exception as e:
                fail += 1
                f_log.write(f"MSG_ERROR | {msg_path} | {repr(e)}\n")

    print(f"Done. MSG ok={ok} fail={fail} | attachments saved={saved}")
    print("Manifest:", manifest_path)
    print("Errors:", log_path)
    print("PDFs folder:", out_pdfs)
    print("Images folder:", out_imgs)

    return run_dir

# --- run it ---
collect_pdf_and_images()
