!python -m pip install -U pdfplumber python-docx pillow
!python -m pip install -U pytesseract

from pathlib import Path
from datetime import datetime
import re

import pdfplumber
from docx import Document
from docx.shared import Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH

from PIL import Image

# Optional OCR (works only if pytesseract + Tesseract installed)
try:
    import pytesseract
    OCR_OK = True
except Exception:
    OCR_OK = False


# =========================
# CONFIG
# =========================
RUN_DIR = Path(r"PASTE_YOUR_RUN_DIR_HERE")  # e.g. ...\_exports\collect_att_20260219_191939
PDF_DIR = RUN_DIR / "pdfs"
IMG_DIR = RUN_DIR / "images"

OUT_DIR = RUN_DIR / f"docx_extracted_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
OUT_PDF = OUT_DIR / "from_pdfs"
OUT_IMG = OUT_DIR / "from_images"
OUT_PDF.mkdir(parents=True, exist_ok=True)
OUT_IMG.mkdir(parents=True, exist_ok=True)


# =========================
# HELPERS
# =========================
def safe_filename(name: str, max_len: int = 150) -> str:
    name = (name or "").strip()
    name = re.sub(r"[<>:\"/\\|?*\x00-\x1F]", "_", name)
    name = re.sub(r"\s+", " ", name)
    if len(name) <= max_len:
        return name
    base, dot, ext = name.rpartition(".")
    if dot:
        base = base[: max_len - (len(ext) + 1)]
        return f"{base}.{ext}"
    return name[:max_len]

def add_heading_meta(doc: Document, title: str, source_path: Path):
    h = doc.add_heading(title, level=1)
    h.alignment = WD_ALIGN_PARAGRAPH.LEFT
    p = doc.add_paragraph()
    p.add_run("Source: ").bold = True
    p.add_run(str(source_path))
    doc.add_paragraph("")

def add_text_block(doc: Document, text: str):
    text = (text or "").strip()
    if not text:
        return
    for line in text.splitlines():
        line = line.strip()
        if line:
            doc.add_paragraph(line)

def add_table(doc: Document, table_data):
    """
    table_data: list of rows, each row is list of cells (strings)
    """
    if not table_data or not isinstance(table_data, list):
        return
    # normalize row lengths
    max_cols = max((len(r) for r in table_data if isinstance(r, list)), default=0)
    if max_cols == 0:
        return
    norm = []
    for r in table_data:
        if not isinstance(r, list):
            continue
        r2 = [(c if c is not None else "") for c in r]
        if len(r2) < max_cols:
            r2 += [""] * (max_cols - len(r2))
        norm.append([str(c).strip() for c in r2])

    if not norm:
        return

    t = doc.add_table(rows=len(norm), cols=max_cols)
    t.style = "Table Grid"
    for i, row in enumerate(norm):
        for j, cell in enumerate(row):
            t.cell(i, j).text = cell
    doc.add_paragraph("")

def extract_pdf_to_docx(pdf_path: Path, out_docx: Path):
    doc = Document()
    add_heading_meta(doc, f"PDF Extraction: {pdf_path.name}", pdf_path)

    with pdfplumber.open(str(pdf_path)) as pdf:
        for page_idx, page in enumerate(pdf.pages, start=1):
            doc.add_heading(f"Page {page_idx}", level=2)

            # 1) Tables first (so you don't lose structure)
            try:
                tables = page.extract_tables(
                    table_settings={
                        "vertical_strategy": "lines",
                        "horizontal_strategy": "lines",
                        "intersection_tolerance": 5,
                        "snap_tolerance": 3,
                        "join_tolerance": 3,
                        "edge_min_length": 3,
                        "min_words_vertical": 3,
                        "min_words_horizontal": 1,
                    }
                ) or []
            except Exception:
                tables = []

            if tables:
                doc.add_paragraph("Tables:")
                for ti, tbl in enumerate(tables, start=1):
                    doc.add_paragraph(f"Table {ti}:")
                    add_table(doc, tbl)

            # 2) Page text
            try:
                text = page.extract_text() or ""
            except Exception:
                text = ""

            if text.strip():
                doc.add_paragraph("Text:")
                add_text_block(doc, text)
            else:
                doc.add_paragraph("(No readable text extracted on this page.)")

            doc.add_page_break()

    doc.save(str(out_docx))

def ocr_image(image_path: Path) -> str:
    if not OCR_OK:
        return ""
    try:
        img = Image.open(str(image_path)).convert("RGB")
        # simple OCR; you can tune language if you want: lang="deu+eng"
        return pytesseract.image_to_string(img)
    except Exception:
        return ""

def extract_image_to_docx(img_path: Path, out_docx: Path, embed_image: bool = True):
    doc = Document()
    add_heading_meta(doc, f"Image Extraction: {img_path.name}", img_path)

    if embed_image:
        try:
            doc.add_paragraph("Image preview:")
            doc.add_picture(str(img_path), width=Inches(6.0))
            doc.add_paragraph("")
        except Exception:
            doc.add_paragraph("(Could not embed image preview.)")
            doc.add_paragraph("")

    text = ocr_image(img_path)
    if text.strip():
        doc.add_paragraph("OCR text:")
        add_text_block(doc, text)
    else:
        if OCR_OK:
            doc.add_paragraph("(OCR returned empty text.)")
        else:
            doc.add_paragraph("(OCR not available: pytesseract/Tesseract not installed.)")

    doc.save(str(out_docx))


# =========================
# RUN
# =========================
pdfs = sorted([p for p in PDF_DIR.glob("*") if p.is_file() and p.suffix.lower() == ".pdf"])
imgs = sorted([p for p in IMG_DIR.glob("*") if p.is_file() and p.suffix.lower() in {".png",".jpg",".jpeg",".tif",".tiff",".bmp",".gif"}])

print("RUN_DIR:", RUN_DIR)
print("PDF files found:", len(pdfs))
print("Image files found:", len(imgs))
print("OCR available:", OCR_OK)
print("Output:", OUT_DIR)

ok_pdf = fail_pdf = 0
for p in pdfs:
    out = OUT_PDF / safe_filename(p.stem + ".docx")
    try:
        extract_pdf_to_docx(p, out)
        ok_pdf += 1
    except Exception as e:
        fail_pdf += 1
        print("PDF FAIL:", p.name, "->", repr(e))

ok_img = fail_img = 0
for p in imgs:
    out = OUT_IMG / safe_filename(p.stem + ".docx")
    try:
        extract_image_to_docx(p, out, embed_image=True)
        ok_img += 1
    except Exception as e:
        fail_img += 1
        print("IMG FAIL:", p.name, "->", repr(e))

print(f"Done. PDFs ok={ok_pdf} fail={fail_pdf} | Images ok={ok_img} fail={fail_img}")
print("DOCX from PDFs:", OUT_PDF)
print("DOCX from images:", OUT_IMG)
