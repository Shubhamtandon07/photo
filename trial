# ================================
# .MSG -> ONE .DOCX per email (REDacted)
# FIXED: Windows path too long
# - attachment folders use short IDs (no subject-based folder names)
# - run folder name shortened
# ================================

import os
import re
import sys
import json
import hashlib
import traceback
from pathlib import Path
from datetime import datetime
import html as html_mod

# ---------- CONFIG ----------
MSG_DIR = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Mails Rasmus"
OUT_DIR = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Mails Rasmus\_exports"

BODY_MAX_CHARS = 250_000
ATTACH_TEXT_MAX_CHARS = 25_000
PDF_MAX_PAGES = 50
XLSX_MAX_SHEETS = 10
XLSX_MAX_ROWS = 400
XLSX_MAX_COLS = 40

FORCE_REDACT_NAMES = [
    "lisa", "dario", "tim", "daniel", "rasmus", "marvin", "victoria",
    "janina", "veronika", "athanasia", "alina", "anne"
]

# ---------- OPTIONAL IMPORTS ----------
def try_import(name):
    try:
        __import__(name)
        return sys.modules[name]
    except Exception:
        return None

extract_msg = try_import("extract_msg")

docx_mod = None
try:
    import docx as docx_mod  # python-docx
except Exception:
    docx_mod = None

pdfplumber = try_import("pdfplumber")
openpyxl = try_import("openpyxl")

PIL_Image = None
pytesseract = None
try:
    from PIL import Image as PIL_Image
except Exception:
    PIL_Image = None
try:
    import pytesseract
except Exception:
    pytesseract = None


# ---------- UTIL ----------
def now_ts():
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def ensure_dir(p: Path) -> Path:
    p.mkdir(parents=True, exist_ok=True)
    return p

def safe_str(x) -> str:
    if x is None:
        return ""
    try:
        return str(x)
    except Exception:
        try:
            return repr(x)
        except Exception:
            return ""

def sanitize_filename(name: str, max_len: int = 80) -> str:
    """
    Keep filenames short to avoid WinError 206.
    """
    name = safe_str(name).strip()
    name = re.sub(r"[\\/:*?\"<>|]+", "_", name)
    name = re.sub(r"\s+", " ", name).strip()
    if len(name) > max_len:
        name = name[:max_len].rstrip()
    return name or "message"

def stable_short_id(path: Path) -> str:
    """
    Short deterministic id for a msg file path.
    """
    h = hashlib.sha1(str(path).encode("utf-8", errors="ignore")).hexdigest()
    return h[:8]

def log_line(log_path: Path, line: str):
    with log_path.open("a", encoding="utf-8") as f:
        f.write(f"[{now_ts()}] {line}\n")


# ---------- HTML->TEXT ----------
def strip_html_to_text(html: str) -> str:
    h = safe_str(html)
    h = re.sub(r"(?is)<(script|style).*?>.*?</\1>", " ", h)
    h = re.sub(r"(?i)<br\s*/?>", "\n", h)
    h = re.sub(r"(?i)</p\s*>", "\n\n", h)
    h = re.sub(r"(?is)<.*?>", " ", h)
    try:
        h = html_mod.unescape(h)
    except Exception:
        pass
    h = re.sub(r"[ \t]+\n", "\n", h)
    h = re.sub(r"\n{3,}", "\n\n", h)
    h = re.sub(r"[ \t]{2,}", " ", h)
    return h.strip()


# ---------- BODY EXTRACTION ----------
def body_best_effort(msg) -> str:
    b = safe_str(getattr(msg, "body", "") or "")
    if b.strip():
        return b.strip()

    hb = safe_str(getattr(msg, "htmlBody", "") or "")
    if hb.strip():
        t = strip_html_to_text(hb)
        if t.strip():
            return t.strip()

    rb = getattr(msg, "rtfBody", None)
    if rb is not None:
        try:
            if isinstance(rb, (bytes, bytearray)):
                rb = rb.decode("utf-8", errors="ignore")
            rb = safe_str(rb).strip()
            if rb:
                rb2 = re.sub(r"{\\.*?}", " ", rb)
                rb2 = re.sub(r"\\[a-zA-Z]+\d*\s?", " ", rb2)
                rb2 = re.sub(r"[{}]", " ", rb2)
                rb2 = re.sub(r"\s{2,}", " ", rb2).strip()
                if rb2:
                    return rb2
        except Exception:
            pass

    return ""


# ---------- REDACTION ----------
LEGAL_SUFFIXES = {"gmbh", "ag", "kg", "kgaa", "se", "inc", "ltd", "llc", "plc", "bv", "nv", "oy", "sas", "sarl"}
STREET_WORDS = ["straße", "strasse", "str.", "street", "st.", "weg", "allee", "platz", "gasse", "ring", "chaussee", "road", "rd", "avenue", "av.", "boulevard", "blvd"]
HEADER_CUE_LINES = ["von:", "from:", "an:", "to:", "cc:", "kopie:", "bcc:", "gesendet:", "sent:", "betreff:", "subject:", "priorität:", "priority:", "mail to:", "mailto:"]

FORCE_NAME_RE = re.compile(r"\b(" + "|".join(map(re.escape, FORCE_REDACT_NAMES)) + r")\b", re.IGNORECASE)

def redact_names_heuristic(text: str) -> str:
    pat = re.compile(r"\b([A-ZÄÖÜ][a-zäöüß]+(?:\s+[A-ZÄÖÜ][a-zäöüß]+){1,2})\b")
    def repl(m):
        phrase = m.group(1)
        low = phrase.lower()
        for sfx in LEGAL_SUFFIXES:
            if f" {sfx}" in low or low.endswith(sfx):
                return phrase
        if any(w in low for w in ["mercedes", "benz", "plant", "werk", "procurement", "supplier", "quality"]):
            return phrase
        return "[REDACTED_NAME]"
    return pat.sub(repl, text)

def redact_text(text: str) -> str:
    t = safe_str(text)

    # force redact your specified names
    t = FORCE_NAME_RE.sub("[REDACTED_NAME]", t)

    # strip header lines
    lines = t.splitlines()
    cleaned = []
    for line in lines:
        l = line.strip()
        low = l.lower()
        if any(low.startswith(cue) for cue in HEADER_CUE_LINES):
            continue
        if low.startswith("_____") or low.startswith("----") or low.startswith("original message"):
            continue
        cleaned.append(line)
    t = "\n".join(cleaned)

    # emails
    t = re.sub(r"\b[a-zA-Z0-9._%+\-]+@[a-zA-Z0-9.\-]+\.[a-zA-Z]{2,}\b", "[REDACTED_EMAIL]", t)
    # phones (broad)
    t = re.sub(r"(?<!\d)(\+?\d[\d\s()./\-]{6,}\d)(?!\d)", "[REDACTED_PHONE]", t)
    # IBAN
    t = re.sub(r"\b[A-Z]{2}\d{2}[A-Z0-9]{11,30}\b", "[REDACTED_IBAN]", t)
    # postal code + city
    t = re.sub(r"\b\d{5}\s+[A-Za-zÄÖÜäöüß][A-Za-zÄÖÜäöüß\-]{2,}\b", "[REDACTED_LOCATION]", t)
    # street addresses
    street_word_re = "|".join([re.escape(w) for w in STREET_WORDS])
    t = re.sub(
        rf"\b([A-Za-zÄÖÜäöüß][A-Za-zÄÖÜäöüß\-\s]{{2,60}}\s(?:{street_word_re})\s*\d{{1,4}}[A-Za-z]?)\b",
        "[REDACTED_ADDRESS]",
        t,
        flags=re.IGNORECASE
    )
    # internal codes
    t = re.sub(r"\b0\d{2}-[A-Z0-9]+\b", "[REDACTED_INTERNAL]", t)
    t = re.sub(r"\b0\d{2}/[A-Z]{2,}\b", "[REDACTED_INTERNAL]", t)
    t = re.sub(r"\bMP/RM\d\b", "[REDACTED_INTERNAL]", t)

    # greeting lines
    t = re.sub(r"(?im)^(hallo|hi|guten morgen|guten tag|sehr geehrte[rn]?|dear|hello)\s+.+?$",
               r"\1 [REDACTED_NAME]", t)

    # heuristic multiword names
    t = redact_names_heuristic(t)

    # enforce again (safe)
    t = FORCE_NAME_RE.sub("[REDACTED_NAME]", t)

    # cleanup
    t = re.sub(r"[ \t]{2,}", " ", t)
    t = re.sub(r"\n{4,}", "\n\n\n", t)
    return t.strip()


# ---------- ATTACHMENT EXTRACTION ----------
def ocr_image_to_text(img_path: Path) -> str:
    if PIL_Image is None or pytesseract is None:
        return ""
    try:
        img = PIL_Image.open(str(img_path)).convert("RGB")
        return safe_str(pytesseract.image_to_string(img)).strip()
    except Exception:
        return ""

def extract_attachment_text(path: Path) -> str:
    if not path.exists() or not path.is_file():
        return ""
    ext = path.suffix.lower()

    if ext in [".txt", ".csv", ".log"]:
        for enc in ("utf-8", "utf-8-sig", "latin-1"):
            try:
                return path.read_text(encoding=enc, errors="ignore")
            except Exception:
                pass
        return ""

    if ext == ".pdf" and pdfplumber is not None:
        try:
            parts = []
            with pdfplumber.open(str(path)) as pdf:
                for p in pdf.pages[:PDF_MAX_PAGES]:
                    txt = p.extract_text() or ""
                    if txt.strip():
                        parts.append(txt)
            return "\n\n".join(parts).strip()
        except Exception:
            return ""

    if ext in [".xlsx", ".xlsm"] and openpyxl is not None:
        try:
            wb = openpyxl.load_workbook(str(path), data_only=True, read_only=True)
            out = []
            for ws in wb.worksheets[:XLSX_MAX_SHEETS]:
                out.append(f"[Sheet] {ws.title}")
                for r_i, row in enumerate(ws.iter_rows(values_only=True), start=1):
                    if r_i > XLSX_MAX_ROWS:
                        break
                    vals = []
                    for v in row[:XLSX_MAX_COLS]:
                        if v is None:
                            continue
                        s = safe_str(v).strip()
                        if s:
                            vals.append(s)
                    if vals:
                        out.append(" | ".join(vals))
            return "\n".join(out).strip()
        except Exception:
            return ""

    if ext == ".docx" and docx_mod is not None:
        try:
            d = docx_mod.Document(str(path))
            paras = [p.text for p in d.paragraphs if p.text and p.text.strip()]
            return "\n".join(paras).strip()
        except Exception:
            return ""

    if ext in [".png", ".jpg", ".jpeg", ".tif", ".tiff", ".bmp"]:
        return ocr_image_to_text(path)

    return ""


# ---------- ATTACHMENT SAVING (robust + short paths) ----------
def save_attachments_robust(msg_obj, target_dir: Path, log_path: Path):
    ensure_dir(target_dir)

    saver = getattr(msg_obj, "saveAttachments", None)
    if callable(saver):
        try:
            saver(customPath=str(target_dir))
            return
        except TypeError:
            try:
                saver(str(target_dir))
                return
            except Exception as e:
                log_line(log_path, f"WARNING: saveAttachments failed: {repr(e)}")
        except Exception as e:
            log_line(log_path, f"WARNING: saveAttachments failed: {repr(e)}")

    atts = getattr(msg_obj, "attachments", None)
    if atts:
        try:
            for a in atts:
                try:
                    save_fn = getattr(a, "save", None)
                    if callable(save_fn):
                        try:
                            save_fn(customPath=str(target_dir))
                        except TypeError:
                            save_fn(str(target_dir))
                except Exception as e:
                    log_line(log_path, f"WARNING: attachment.save failed: {repr(e)}")
            return
        except Exception as e:
            log_line(log_path, f"WARNING: iter attachments failed: {repr(e)}")

    save_fn = getattr(msg_obj, "save", None)
    if callable(save_fn):
        try:
            save_fn(customPath=str(target_dir))
        except Exception as e:
            log_line(log_path, f"WARNING: msg.save failed: {repr(e)}")


# ---------- WRITE DOCX ----------
def add_text_preserve_lines(doc, text: str):
    for line in (text or "").splitlines():
        doc.add_paragraph(line)

def msg_to_docx_one_file(msg_path: Path, out_docx: Path, att_root: Path, log_path: Path, msg_index: int):
    m = extract_msg.Message(str(msg_path))
    proc = getattr(m, "process", None)
    if callable(proc):
        proc()

    subject = safe_str(getattr(m, "subject", "") or "").strip() or msg_path.stem
    date = safe_str(getattr(m, "date", "") or "").strip()

    body = body_best_effort(m)[:BODY_MAX_CHARS]

    subject_r = redact_text(subject)
    body_r = redact_text(body)

    # SHORT folder name to avoid WinError 206
    sid = stable_short_id(msg_path)
    msg_att_dir = ensure_dir(att_root / f"att_{msg_index:05d}_{sid}")
    save_attachments_robust(m, msg_att_dir, log_path)

    # Extract attachment text
    attachments_info = []
    supported_exts = {".pdf", ".xlsx", ".xlsm", ".docx", ".txt", ".csv", ".log", ".png", ".jpg", ".jpeg", ".tif", ".tiff", ".bmp"}

    for fp in sorted(msg_att_dir.glob("*")):
        if not fp.is_file():
            continue
        if fp.suffix.lower() not in supported_exts:
            continue

        raw = extract_attachment_text(fp)
        red = redact_text(raw)[:ATTACH_TEXT_MAX_CHARS] if raw.strip() else ""

        attachments_info.append({"name": fp.name, "ext": fp.suffix.lower(), "text": red})

    # Write docx
    doc = docx_mod.Document()
    doc.add_heading(subject_r, level=1)
    if date:
        doc.add_paragraph(f"Date: {redact_text(date)}")

    doc.add_paragraph("")
    doc.add_heading("Body (redacted)", level=2)
    if body_r.strip():
        add_text_preserve_lines(doc, body_r)
    else:
        doc.add_paragraph("(no usable body text extracted)")

    doc.add_paragraph("")
    doc.add_heading("Attachments (redacted excerpts)", level=2)

    if attachments_info:
        for a in attachments_info:
            doc.add_heading(a["name"], level=3)
            if a["text"].strip():
                add_text_preserve_lines(doc, a["text"])
            else:
                doc.add_paragraph("(no text extracted; could be scanned/embedded or extractor/OCR not available)")
            doc.add_paragraph("")
    else:
        doc.add_paragraph("(no supported attachments found or extraction not available)")

    out_docx.parent.mkdir(parents=True, exist_ok=True)
    doc.save(str(out_docx))

    try:
        close_fn = getattr(m, "close", None)
        if callable(close_fn):
            close_fn()
    except Exception:
        pass


# ---------- MAIN ----------
def run_all():
    if extract_msg is None:
        raise RuntimeError("Missing extract-msg. Install: py -m pip install -U extract-msg")
    if docx_mod is None:
        raise RuntimeError("Missing python-docx. Install: py -m pip install -U python-docx")

    src = Path(MSG_DIR)
    out_root = Path(OUT_DIR)
    if not src.exists():
        raise FileNotFoundError(f"MSG_DIR not found: {src}")

    # SHORT run folder name
    run_id = datetime.now().strftime("run_%Y%m%d_%H%M%S")
    run_dir = ensure_dir(out_root / run_id)

    docx_dir = ensure_dir(run_dir / "docx")
    att_root = ensure_dir(run_dir / "att")
    log_path = run_dir / "errors.log"
    index_path = run_dir / "index.jsonl"

    msg_files = sorted(src.rglob("*.msg"))
    print(f"Found .msg files: {len(msg_files)}")
    print(f"Output run folder: {run_dir}")

    print("Extractor availability:")
    print(f"  pdfplumber:  {'OK' if pdfplumber else 'MISSING'}")
    print(f"  openpyxl:    {'OK' if openpyxl else 'MISSING'}")
    print(f"  pytesseract: {'OK' if pytesseract else 'MISSING'}")
    print(f"  pillow:      {'OK' if PIL_Image else 'MISSING'}")

    ok = 0
    fail = 0

    with index_path.open("w", encoding="utf-8") as idx:
        for i, p in enumerate(msg_files, start=1):
            try:
                # Short safe docx name too
                sid = stable_short_id(p)
                out_docx = docx_dir / f"mail_{i:05d}_{sid}.docx"

                msg_to_docx_one_file(p, out_docx, att_root, log_path, i)

                idx.write(json.dumps({"source": str(p), "out_docx": str(out_docx), "generated": now_ts()},
                                     ensure_ascii=False) + "\n")

                ok += 1
                if i % 25 == 0:
                    print(f"Progress: {i}/{len(msg_files)} | ok={ok} fail={fail}")

            except Exception as e:
                fail += 1
                log_line(log_path, f"ERROR: {p.name} -> {repr(e)}")
                log_line(log_path, traceback.format_exc())

    print(f"Done. ok={ok} fail={fail}")
    if fail:
        print(f"See errors: {log_path}")


run_all()
