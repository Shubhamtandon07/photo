# -*- coding: utf-8 -*-
"""
Outlook Draft Bot (NO LLM)
- Reads incoming emails with subject exactly "bot"
- Retrieves best answer from documents (prefers real docs, avoids mail chains)
- Drafts reply in German + English (DeepL for translation)
- Marks processed email as READ + adds category to avoid duplicates
- Sends self notification + 2-day reminder email to yourself

Python: 3.14 (works)
"""

import os
import re
import time
import hashlib
from pathlib import Path
from datetime import datetime, timedelta
from typing import List, Tuple, Optional

import win32com.client as win32

# -------------------------
# CONFIG (EDIT THESE)
# -------------------------
TARGET_MAILBOX = "shubham.tandon@mercedes-benz.com"   # mailbox display name substring match
WATCH_FOLDER_NAME = "Inbox"                           # "Inbox" or subfolder under Inbox

KB_DIR = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Test Data"

REQUIRE_UNREAD = True
PROCESS_PER_RUN = 5
SCAN_LIMIT = 250
STARTUP_DELAY_SEC = 2

PROCESSED_CATEGORY = "AI-Drafted"
SELF_NOTIFY_TO = TARGET_MAILBOX
REMINDER_DAYS = 2

# Retrieval
SUPPORTED_EXTS = {".txt", ".docx", ".pdf", ".xlsx", ".html", ".htm"}
MAX_FILES = 8
MAX_CHARS_PER_FILE = 7000
MAX_TOTAL_CHARS = 25000

# Avoid citing mail chains as sources (you explicitly asked this)
# Anything with AW_/WG_/RE_/FW_ etc. is treated as "mail chain" and excluded from citations.
MAILCHAIN_NAME_CUES = re.compile(r"^(aw_|wg_|re_|fw_|fwd_|antwort|reply)", re.IGNORECASE)

# DeepL env var
DEEPL_AUTH_KEY_ENV = "DEEPL_AUTH_KEY"

# -------------------------
# Helpers
# -------------------------
def clean_ws(s: str) -> str:
    return re.sub(r"\s+", " ", s or "").strip()

def strict_subject_is_bot(subject: str) -> bool:
    s = (subject or "").strip().lower()
    return s == "bot"

def safe_firstname_from_email(email: str) -> str:
    email = (email or "").strip()
    local = email.split("@", 1)[0] if "@" in email else email
    first = local.split(".", 1)[0].strip()
    if not first:
        return "there"
    return first[:1].upper() + first[1:]

def safe_your_firstname_from_mailbox(mailbox: str) -> str:
    local = (mailbox or "").split("@", 1)[0]
    first = local.split(".", 1)[0].strip()
    return (first[:1].upper() + first[1:]) if first else "Best regards"

def get_sender_smtp(mail) -> str:
    try:
        addr = (mail.SenderEmailAddress or "").lower()
        if addr.startswith("/o="):
            ex = mail.Sender.GetExchangeUser()
            if ex:
                return (ex.PrimarySmtpAddress or "").lower()
        return addr
    except Exception:
        return (getattr(mail, "SenderEmailAddress", "") or "").lower()

def clean_html_to_text(html: str) -> str:
    # basic HTML strip; good enough for Outlook bodies
    txt = re.sub(r"<(script|style)[^>]*>.*?</\1>", " ", html or "", flags=re.I | re.S)
    txt = re.sub(r"<br\s*/?>", "\n", txt, flags=re.I)
    txt = re.sub(r"</p\s*>", "\n\n", txt, flags=re.I)
    txt = re.sub(r"<[^>]+>", " ", txt, flags=re.S)
    return (txt or "").replace("\r\n", "\n").strip()

# -------------------------
# Redaction (remove people/supplier identifiers etc.)
# -------------------------
EMAIL_RE = re.compile(r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b")
URL_RE = re.compile(r"\bhttps?://[^\s<>()]+\b", re.I)
PHONE_RE = re.compile(r"(?:(?:\+|00)\d{1,3}[\s\-]?)?(?:\(?\d{2,6}\)?[\s\-]?)?\d[\d\s\-]{6,}\d")
IBAN_RE = re.compile(r"\b[A-Z]{2}\d{2}[A-Z0-9]{11,30}\b", re.I)
MONEY_RE = re.compile(r"(?i)\b(?:EUR|USD|GBP|CHF)\s*\d[\d\.\,\s]*\b|\b\d[\d\.\,\s]*\s*(?:€|EUR|USD|GBP|CHF)\b")
ADDRESS_DE_RE = re.compile(
    r"\b([A-ZÄÖÜ][a-zäöüß]+(?:\s[A-ZÄÖÜ][a-zäöüß]+){0,3})\s"
    r"(Straße|Strasse|Str\.|Weg|Allee|Platz|Ring|Gasse|Damm|Ufer)\s"
    r"\d{1,5}[a-zA-Z]?\b"
)

# Heuristic person names: greeting sign-offs and simple First Last
GREETING_NAME_RE = re.compile(r"(?im)^\s*(hallo|hi|guten\s+morgen|guten\s+tag|hello|dear)\s+([^\n,]{2,40})[,!]\s*$")
SIGNOFF_NAME_RE  = re.compile(r"(?im)^\s*(vg|lg|br|mfg|mit\s+freundlichen\s+grüßen|best\s+regards|kind\s+regards)\s*\n+\s*([A-ZÄÖÜ][^\n]{1,50})\s*$")
FIRST_LAST_RE    = re.compile(r"\b[A-ZÄÖÜ][a-zäöüß]{1,}\s+[A-ZÄÖÜ][a-zäöüß]{1,}\b")

def redact_sensitive(text: str) -> str:
    if not text:
        return ""

    t = text
    t = EMAIL_RE.sub("[EMAIL]", t)
    t = URL_RE.sub("[URL]", t)
    t = PHONE_RE.sub("[PHONE]", t)
    t = IBAN_RE.sub("[IBAN]", t)
    t = MONEY_RE.sub("[AMOUNT]", t)
    t = ADDRESS_DE_RE.sub("[ADDRESS]", t)

    # Replace greeting names + sign-off names
    def _greet_sub(m):
        return f"{m.group(1)} [PERSON],"
    t = GREETING_NAME_RE.sub(_greet_sub, t)

    def _sign_sub(m):
        # keep the signoff word but remove name line
        return f"{m.group(1)}\n[PERSON]"
    t = SIGNOFF_NAME_RE.sub(_sign_sub, t)

    # Replace generic First Last occurrences
    t = FIRST_LAST_RE.sub("[PERSON]", t)

    # Remove typical Outlook headers inside bodies
    t = re.sub(r"(?im)^\s*(von|from|an|to|cc|betreff|subject|gesendet|sent)\s*:\s*.*$", "", t)

    # cleanup
    t = re.sub(r"\n{3,}", "\n\n", t)
    return t.strip()

# -------------------------
# DeepL translation
# -------------------------
def deepl_translate(text: str, target_lang: str) -> Optional[str]:
    """
    target_lang: 'DE' or 'EN-US' etc.
    Returns None if DeepL not available or key missing.
    """
    key = os.getenv(DEEPL_AUTH_KEY_ENV)
    if not key:
        return None

    try:
        import deepl
        translator = deepl.Translator(key)
        res = translator.translate_text(text, target_lang=target_lang)
        return str(res)
    except Exception:
        return None

# -------------------------
# KB readers (skip missing libs gracefully)
# -------------------------
def read_txt(p: Path) -> str:
    return p.read_text(encoding="utf-8", errors="ignore")

def read_docx(p: Path) -> str:
    try:
        from docx import Document
    except Exception:
        return ""
    doc = Document(str(p))
    parts = [clean_ws(par.text) for par in doc.paragraphs if clean_ws(par.text)]
    return "\n".join(parts)

def read_pdf(p: Path) -> str:
    # Prefer pdfplumber if installed; fallback to pypdf
    try:
        import pdfplumber
        out = []
        with pdfplumber.open(str(p)) as pdf:
            for pg in pdf.pages:
                out.append(pg.extract_text() or "")
        return "\n".join(out)
    except Exception:
        pass

    try:
        from pypdf import PdfReader
        out = []
        r = PdfReader(str(p))
        for pg in r.pages:
            try:
                out.append(pg.extract_text() or "")
            except Exception:
                pass
        return "\n".join(out)
    except Exception:
        return ""

def read_xlsx(p: Path) -> str:
    try:
        import openpyxl
    except Exception:
        return ""
    wb = openpyxl.load_workbook(str(p), data_only=True, read_only=True)
    out = []
    for ws in wb.worksheets:
        out.append(f"Sheet: {ws.title}")
        max_rows = min(ws.max_row or 0, 200)
        max_cols = min(ws.max_column or 0, 30)
        for r in range(1, max_rows + 1):
            row_vals = []
            for c in range(1, max_cols + 1):
                v = ws.cell(row=r, column=c).value
                row_vals.append("" if v is None else str(v))
            if any(cell.strip() for cell in row_vals):
                out.append(" | ".join(clean_ws(x) for x in row_vals))
    return "\n".join(out)

def read_html(p: Path) -> str:
    try:
        html = p.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return ""
    return clean_html_to_text(html)

def extract_text_from_file(p: Path) -> str:
    ext = p.suffix.lower()
    try:
        if ext == ".txt":
            return clean_ws(read_txt(p))
        if ext == ".docx":
            return clean_ws(read_docx(p))
        if ext == ".pdf":
            return clean_ws(read_pdf(p))
        if ext == ".xlsx":
            return clean_ws(read_xlsx(p))
        if ext in (".html", ".htm"):
            return clean_ws(read_html(p))
    except Exception:
        return ""
    return ""

def load_kb(dirpath: str) -> List[Tuple[str, str, bool]]:
    """
    Returns list of (filename, text, is_mailchain_like)
    """
    base = Path(dirpath)
    if not base.exists() or not base.is_dir():
        raise SystemExit(f"KB_DIR not found or not a folder: {dirpath}")

    files = [p for p in base.rglob("*") if p.is_file() and p.suffix.lower() in SUPPORTED_EXTS]
    out: List[Tuple[str, str, bool]] = []

    for p in sorted(files):
        txt = extract_text_from_file(p)
        if not txt:
            continue
        name = p.name
        is_mailchain = bool(MAILCHAIN_NAME_CUES.search(Path(name).stem))
        out.append((name, txt[:MAX_CHARS_PER_FILE], is_mailchain))

    if not out:
        raise SystemExit("No extractable KB text found.")
    return out

# -------------------------
# Retrieval / Answer building (deterministic)
# -------------------------
def score_doc(query: str, text: str, name: str) -> int:
    """
    Simple scoring:
    - keyword overlap
    - slightly prefer non-mailchain docs (handled later)
    """
    q = (query or "").lower()
    tokens = [t for t in re.split(r"[^a-z0-9äöüß]+", q) if len(t) >= 3]
    t = text.lower()

    score = 0
    for tok in set(tokens):
        if tok in t:
            score += 2
    # filename cue boost (doc names sometimes match)
    for tok in set(tokens):
        if tok in Path(name).stem.lower():
            score += 4
    return score

def pick_best_snippets(kb: List[Tuple[str, str, bool]], question: str, max_files: int) -> List[Tuple[str, str, bool, int]]:
    scored = []
    for name, txt, is_mailchain in kb:
        s = score_doc(question, txt, name)
        if s > 0:
            scored.append((name, txt, is_mailchain, s))

    # Sort:
    # - higher score first
    # - prefer non-mailchain docs
    scored.sort(key=lambda x: (x[3], 0 if not x[2] else -1), reverse=True)

    # cap total chars
    picked = scored[:max_files]
    total = 0
    out = []
    for name, txt, is_mailchain, s in picked:
        if total + len(txt) > MAX_TOTAL_CHARS:
            remain = max(0, MAX_TOTAL_CHARS - total)
            out.append((name, txt[:remain], is_mailchain, s))
            break
        out.append((name, txt, is_mailchain, s))
        total += len(txt)
    return out

def extract_answer_like_lines(snips: List[Tuple[str, str, bool, int]], question: str) -> str:
    """
    Deterministic "answer": pull the most relevant sentences/lines from top docs.
    No mail citations in output; internal use only.
    """
    q = clean_ws(question)
    q_tokens = [t for t in re.split(r"[^A-Za-z0-9ÄÖÜäöüß]+", q.lower()) if len(t) >= 3]
    q_tokens = list(dict.fromkeys(q_tokens))[:20]

    candidates = []
    for name, txt, is_mailchain, s in snips:
        # split into sentences-ish
        parts = re.split(r"(?<=[\.\!\?])\s+|\n+", txt)
        for p in parts:
            line = clean_ws(p)
            if len(line) < 20:
                continue
            l = line.lower()
            hit = sum(1 for tok in q_tokens if tok in l)
            if hit >= 2:
                candidates.append((hit, s, is_mailchain, line))

    # Prefer non-mailchain lines
    candidates.sort(key=lambda x: (x[0], x[1], 0 if not x[2] else -1), reverse=True)

    if not candidates:
        return ""

    # Build short answer from top lines
    out = []
    used = set()
    for hit, s, is_mailchain, line in candidates[:8]:
        if line in used:
            continue
        used.add(line)
        out.append(line)
        if sum(len(x) for x in out) > 900:
            break

    return "\n".join(out).strip()

def build_reply_text_bilingual(sender_first: str, your_first: str, answer_de: str, answer_en: str) -> str:
    # polite, not mentioning "based on documents"
    de = answer_de.strip() if answer_de.strip() else "Ich konnte dazu in den verfügbaren Dokumenten keine eindeutige Information finden."
    en = answer_en.strip() if answer_en.strip() else "I could not find a clear, explicit answer in the available documents."

    return (
        f"Hallo {sender_first},\n"
        f"ich hoffe, es geht dir gut.\n\n"
        f"{de}\n\n"
        f"---\n"
        f"English version:\n\n"
        f"Hello {sender_first},\n"
        f"I hope you are doing well.\n\n"
        f"{en}\n\n"
        f"Mit freundlichen Grüßen / Best regards\n"
        f"{your_first}\n"
    )

# -------------------------
# Outlook actions
# -------------------------
def get_target_folder():
    ns = win32.Dispatch("Outlook.Application").GetNamespace("MAPI")

    target_store = None
    for st in ns.Stores:
        if TARGET_MAILBOX.lower() in (st.DisplayName or "").lower():
            target_store = st
            break
    if not target_store:
        raise SystemExit("Target mailbox not found in Outlook stores.")

    inbox = target_store.GetDefaultFolder(6)  # Inbox
    if WATCH_FOLDER_NAME.lower() == "inbox":
        return ns, inbox, target_store.DisplayName, "Inbox"

    for f in inbox.Folders:
        if (f.Name or "").lower() == WATCH_FOLDER_NAME.lower():
            return ns, f, target_store.DisplayName, f.Name

    raise SystemExit(f"Subfolder '{WATCH_FOLDER_NAME}' not found under Inbox of {target_store.DisplayName}")

def add_processed_category_and_mark_read(mail):
    try:
        cats = mail.Categories or ""
        if PROCESSED_CATEGORY.lower() not in cats.lower():
            mail.Categories = (cats + "," + PROCESSED_CATEGORY).strip(",")
        mail.UnRead = False
        mail.Save()
    except Exception:
        pass

def send_self_notification(ns, orig_subject: str, requester_email: str):
    msg = ns.Application.CreateItem(0)
    msg.To = SELF_NOTIFY_TO
    msg.Subject = f"Draft created (review needed): {orig_subject}"
    msg.Body = (
        "A draft reply was created in Outlook.\n\n"
        f"Original subject: {orig_subject}\n"
        f"Requester: {requester_email}\n\n"
        "Please review the draft carefully before sending."
    )
    msg.Send()

def schedule_reminder_email(ns, orig_subject: str):
    """
    Sends an email to yourself in 2 days (DeferredDeliveryTime).
    Works as a reminder even if user forgets.
    """
    try:
        msg = ns.Application.CreateItem(0)
        msg.To = SELF_NOTIFY_TO
        msg.Subject = f"Reminder: review/send draft for '{orig_subject}'"
        msg.Body = (
            "Reminder: A draft reply was created earlier.\n"
            "If it has not been sent yet, please review and send it."
        )
        msg.DeferredDeliveryTime = (datetime.now() + timedelta(days=REMINDER_DAYS))
        msg.Send()
    except Exception:
        pass

# -------------------------
# MAIN RUN
# -------------------------
def run_bot_once():
    time.sleep(STARTUP_DELAY_SEC)

    print("Loading KB from:", KB_DIR)
    kb = load_kb(KB_DIR)
    print("KB loaded:", len(kb), "documents")

    ns, folder, store_name, folder_name = get_target_folder()
    print(f"Mailbox={store_name} | Folder={folder_name}")

    items = folder.Items
    items.Sort("[ReceivedTime]", True)

    drafted = 0
    checked = 0

    your_first = safe_your_firstname_from_mailbox(TARGET_MAILBOX)

    for mail in items:
        checked += 1
        if checked > SCAN_LIMIT:
            break
        if drafted >= PROCESS_PER_RUN:
            break

        try:
            # MailItem class = 43
            if getattr(mail, "Class", None) != 43:
                continue

            # skip already processed
            if PROCESSED_CATEGORY.lower() in (mail.Categories or "").lower():
                continue

            if REQUIRE_UNREAD and not mail.UnRead:
                continue

            subject = mail.Subject or ""
            if not strict_subject_is_bot(subject):
                continue

            sender = get_sender_smtp(mail)
            sender_first = safe_firstname_from_email(sender)

            body_text = clean_html_to_text(getattr(mail, "HTMLBody", "") or getattr(mail, "Body", "") or "")
            body_text = redact_sensitive(body_text)

            # the "question" is basically the email body (sanitized)
            question = body_text if body_text.strip() else "(no body text provided)"

            # retrieval
            snips = pick_best_snippets(kb, question, MAX_FILES)

            # build deterministic answer (German base)
            answer_de_raw = extract_answer_like_lines(snips, question)
            answer_de = redact_sensitive(answer_de_raw)

            # translate into English via DeepL (fallback: reuse DE if translation fails)
            answer_en = deepl_translate(answer_de, "EN-US") or ""

            # also ensure German version exists; if question was in EN, we still answer DE+EN
            if not answer_de.strip():
                answer_de = "Ich konnte dazu in den verfügbaren Dokumenten keine eindeutige Information finden."
            if not answer_en.strip():
                # if translation fails, at least give an English fallback
                answer_en = "I could not find a clear, explicit answer in the available documents."

            reply_text = build_reply_text_bilingual(sender_first, your_first, answer_de, answer_en)

            # Draft reply
            reply = mail.Reply()
            reply.Body = reply_text + "\n\n" + (reply.Body or "")
            reply.Save()

            # Mark original as read + category
            add_processed_category_and_mark_read(mail)

            # Notify + reminder
            send_self_notification(ns, subject, sender)
            schedule_reminder_email(ns, subject)

            drafted += 1
            print("Draft created:", subject)

        except Exception as e:
            print("Mail error:", getattr(mail, "Subject", "<no subject>"), "-", repr(e))

    print(f"Done. Checked={checked}, Drafted={drafted}")

if __name__ == "__main__":
    run_bot_once()
