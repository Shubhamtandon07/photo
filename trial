import sys
!{sys.executable} -m pip install -U extract-msg

from pathlib import Path
from datetime import datetime
import hashlib
import csv
import re

import extract_msg

# =========================
# CONFIG
# =========================
ROOT = Path(r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Mails Rasmus")
EXPORT_BASE = ROOT / "_exports"
RUN_ID = datetime.now().strftime("%Y%m%d_%H%M%S")

RUN_DIR = EXPORT_BASE / f"msg_collect_pdfs_images_{RUN_ID}"
PDF_DIR = RUN_DIR / "collected_pdfs"
IMG_DIR = RUN_DIR / "collected_images"
TMP_DIR = RUN_DIR / "_tmp_per_msg"
MANIFEST = RUN_DIR / "manifest.csv"
ERRORS = RUN_DIR / "errors.log"

PDF_EXTS = {".pdf"}
IMG_EXTS = {".png", ".jpg", ".jpeg", ".tif", ".tiff", ".bmp"}  # extend if needed

# =========================
# HELPERS
# =========================
def ensure_dir(p: Path) -> Path:
    p.mkdir(parents=True, exist_ok=True)
    return p

def log_err(msg: str):
    with ERRORS.open("a", encoding="utf-8", errors="ignore") as f:
        f.write(msg + "\n")

def safe_slug(s: str, maxlen: int = 80) -> str:
    s = (s or "").strip()
    s = re.sub(r"[<>:\"/\\|?*\x00-\x1F]", "_", s)   # windows illegal chars
    s = re.sub(r"\s+", " ", s).strip()
    if len(s) > maxlen:
        s = s[:maxlen].rstrip()
    return s or "file"

def short_hash(text: str, n: int = 10) -> str:
    return hashlib.sha1(text.encode("utf-8", errors="ignore")).hexdigest()[:n]

def att_filename(att) -> str:
    # extract-msg varies by version; try multiple fields
    for attr in ("longFilename", "shortFilename", "filename", "name"):
        if hasattr(att, attr):
            v = getattr(att, attr)
            if isinstance(v, str) and v.strip():
                return v.strip()
    return ""

def list_files(folder: Path):
    return {p for p in folder.glob("*") if p.is_file()}

def move_file(src: Path, dst: Path) -> Path:
    ensure_dir(dst.parent)
    # if conflict, add suffix
    if dst.exists():
        stem = dst.stem
        suf = dst.suffix
        dst = dst.with_name(f"{stem}__{short_hash(str(src), 6)}{suf}")
    src.replace(dst)  # atomic move on same drive
    return dst

# =========================
# MAIN COLLECTOR
# =========================
def collect_from_one_msg(msg_path: Path):
    rel = str(msg_path.relative_to(ROOT))
    msg_id = short_hash(rel, 12)
    msg_tmp = ensure_dir(TMP_DIR / msg_id)

    m = extract_msg.Message(str(msg_path))
    try:
        # Some versions need process() to populate metadata/attachments
        if hasattr(m, "process"):
            m.process()
    except Exception:
        pass

    # attachments list
    atts = []
    if hasattr(m, "attachments") and m.attachments:
        atts = m.attachments
    elif hasattr(m, "get_attachments"):
        try:
            atts = m.get_attachments()
        except Exception:
            atts = []

    saved_pdf = []
    saved_img = []

    for i, att in enumerate(atts):
        name = att_filename(att)
        ext = Path(name).suffix.lower() if name else ""

        # If name is missing, we still try saving, then decide by extension afterwards
        before = list_files(msg_tmp)

        try:
            if hasattr(att, "save") and callable(att.save):
                att.save(customPath=str(msg_tmp))
            else:
                # fallback: some attachments expose bytes
                data = getattr(att, "data", None)
                if isinstance(data, bytes) and data:
                    out = msg_tmp / f"att_{i+1}"
                    out.write_bytes(data)
                else:
                    continue
        except Exception as e:
            log_err(f"ATT_SAVE_ERROR | {msg_path.name} | {name} -> {repr(e)}")
            continue

        after = list_files(msg_tmp)
        new_files = sorted(after - before, key=lambda p: p.stat().st_mtime, reverse=True)
        if not new_files:
            # nothing new â†’ skip
            continue

        # Some saves write multiple files (rare). classify each.
        for nf in new_files:
            nf_ext = nf.suffix.lower()
            if nf_ext in PDF_EXTS:
                final_name = f"{safe_slug(msg_path.stem)}__{msg_id}__{i+1}.pdf"
                dst = PDF_DIR / final_name
                saved_pdf.append(move_file(nf, dst))
            elif nf_ext in IMG_EXTS:
                final_name = f"{safe_slug(msg_path.stem)}__{msg_id}__{i+1}{nf_ext}"
                dst = IMG_DIR / final_name
                saved_img.append(move_file(nf, dst))
            else:
                # If original attachment name had extension, but saved file didn't, try using that
                if ext in PDF_EXTS:
                    fixed = nf.with_suffix(".pdf")
                    nf.rename(fixed)
                    final_name = f"{safe_slug(msg_path.stem)}__{msg_id}__{i+1}.pdf"
                    dst = PDF_DIR / final_name
                    saved_pdf.append(move_file(fixed, dst))
                elif ext in IMG_EXTS:
                    fixed = nf.with_suffix(ext)
                    nf.rename(fixed)
                    final_name = f"{safe_slug(msg_path.stem)}__{msg_id}__{i+1}{ext}"
                    dst = IMG_DIR / final_name
                    saved_img.append(move_file(fixed, dst))
                else:
                    # ignore everything else
                    pass

    try:
        m.close()
    except Exception:
        pass

    return len(atts), saved_pdf, saved_img

def run():
    ensure_dir(RUN_DIR)
    ensure_dir(PDF_DIR)
    ensure_dir(IMG_DIR)
    ensure_dir(TMP_DIR)

    msg_files = sorted(ROOT.rglob("*.msg"))
    print("ROOT:", ROOT)
    print("Found .msg files:", len(msg_files))
    print("RUN_DIR:", RUN_DIR)

    ok = 0
    fail = 0
    pdf_count = 0
    img_count = 0

    with MANIFEST.open("w", newline="", encoding="utf-8-sig") as f:
        w = csv.writer(f, delimiter=";")
        w.writerow(["msg_file", "attachments_total", "pdf_saved", "img_saved", "pdf_paths", "img_paths", "status"])

        for p in msg_files:
            try:
                att_total, pdfs, imgs = collect_from_one_msg(p)
                ok += 1
                pdf_count += len(pdfs)
                img_count += len(imgs)

                w.writerow([
                    p.name,
                    att_total,
                    len(pdfs),
                    len(imgs),
                    " | ".join(str(x) for x in pdfs),
                    " | ".join(str(x) for x in imgs),
                    "OK"
                ])

            except Exception as e:
                fail += 1
                log_err(f"MSG_ERROR | {p} -> {repr(e)}")
                w.writerow([p.name, 0, 0, 0, "", "", f"ERROR: {repr(e)}"])

    print(f"Done. OK={ok} FAIL={fail}")
    print("Collected PDFs:", pdf_count, "->", PDF_DIR)
    print("Collected images:", img_count, "->", IMG_DIR)
    print("Manifest:", MANIFEST)
    print("Errors:", ERRORS)

run()
