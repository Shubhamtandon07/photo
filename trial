# -*- coding: utf-8 -*-
"""
Deterministic Outlook Bot (NO LLM) - Bilingual + Document-only citations

Changes vs prior:
- Reply is bilingual: German first, then English.
- "Sources (internal)" and "Relevant references (extracts)" use ONLY valid documents,
  never emails/mail-exports. Email-like files are excluded from citations and extracts.

Behavior:
- Process ONLY if subject is exactly "bot" (case-insensitive). No RE:/AW: allowed.
- Uses KB folder (txt/docx/pdf/xlsx) and builds a lightweight BM25-like index.
- Rule-based intent detection + templates.
- Creates a reply draft in Outlook with readable formatting.
- Adds "Sources (internal)" line listing KB documents used.

Requirements:
  py -m pip install pywin32 python-docx pypdf openpyxl
  # optional: py -m pip install pdfplumber
"""

import re
import math
import time
from dataclasses import dataclass
from pathlib import Path
from typing import List, Tuple, Dict

import win32com.client as win32

# -------------------------
# CONFIG (EDIT)
# -------------------------
TARGET_MAILBOX = "shubham.tandon@mercedes-benz.com"
WATCH_FOLDER_NAME = "Inbox"
STRICT_SUBJECT = "bot"

REQUIRE_UNREAD = True
PROCESS_PER_RUN = 3
SCAN_LIMIT = 250
STARTUP_DELAY_SEC = 2

KB_DIR = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Test Data"
SUPPORTED_EXTS = {".txt", ".docx", ".pdf", ".xlsx"}

# Chunking / retrieval
CHUNK_MAX_CHARS = 900
CHUNK_MIN_CHARS = 180
TOP_K_CHUNKS = 10

# Outlook bookkeeping
PROCESSED_CATEGORY = "AI-Drafted-Deterministic"

# Signature formatting
SIGN_FIRSTNAME_FROM_MAILBOX = True
FALLBACK_SIGN_NAME = "Shubham"

# Document-only citations: exclude mail-like KB files from "sources/extracts"
EXCLUDE_MAIL_SOURCES = True

MAIL_SOURCE_NAME_PATTERNS = [
    r"\baw[_\-\s:]",          # AW:
    r"\bre[_\-\s:]",          # RE:
    r"\bwg[_\-\s:]",          # WG:
    r"\bfw[_\-\s:]",          # FW:
    r"\bantwort\b",           # Antwort
    r"\bmail\b",
    r"\bemail\b",
    r"\bmessage\b",
    r"\bmsg\b",               # exported msg-derived text
    r"\binbox\b",
    r"\boutlook\b",
]

# -------------------------
# Helpers
# -------------------------
TOKEN_RE = re.compile(r"[a-z0-9äöüß]+", re.I)

def clean_ws(s: str) -> str:
    return re.sub(r"\s+", " ", s or "").strip()

def is_strict_subject(subject: str) -> bool:
    s = (subject or "").strip()
    return s.casefold() == STRICT_SUBJECT.casefold()

def first_name_from_email(email: str) -> str:
    e = (email or "").strip().lower()
    if "@" not in e:
        return "there"
    local = e.split("@", 1)[0]
    first = local.split(".", 1)[0].strip()
    if not first:
        return "there"
    return first[:1].upper() + first[1:]

def html_escape(s: str) -> str:
    return (s or "").replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

def clean_html_to_text(html: str) -> str:
    txt = re.sub(r"<[^>]+>", " ", html or "", flags=re.S)
    return clean_ws(txt)

def get_sender_smtp(mail) -> str:
    try:
        addr = (mail.SenderEmailAddress or "").lower()
        if addr.startswith("/o="):
            ex = mail.Sender.GetExchangeUser()
            if ex:
                return (ex.PrimarySmtpAddress or "").lower()
        return addr
    except Exception:
        return (mail.SenderEmailAddress or "").lower()

def add_processed_category(mail):
    try:
        cats = mail.Categories or ""
        if PROCESSED_CATEGORY.lower() not in cats.lower():
            mail.Categories = (cats + "," + PROCESSED_CATEGORY).strip(",")
            mail.Save()
    except Exception:
        pass

def get_target_folder():
    ns = win32.Dispatch("Outlook.Application").GetNamespace("MAPI")

    target_store = None
    for st in ns.Stores:
        if TARGET_MAILBOX.lower() in (st.DisplayName or "").lower():
            target_store = st
            break

    if not target_store:
        print("Available Outlook stores:")
        for st in ns.Stores:
            print(" -", st.DisplayName)
        raise SystemExit("Target mailbox not found. Set TARGET_MAILBOX to match Store.DisplayName.")

    inbox = target_store.GetDefaultFolder(6)  # Inbox

    if WATCH_FOLDER_NAME.lower() == "inbox":
        return inbox, target_store.DisplayName, "Inbox"

    for f in inbox.Folders:
        if (f.Name or "").lower() == WATCH_FOLDER_NAME.lower():
            return f, target_store.DisplayName, f.Name

    raise SystemExit(f"Subfolder '{WATCH_FOLDER_NAME}' not found under Inbox of {target_store.DisplayName}")

def tokenize(text: str) -> List[str]:
    return [t.lower() for t in TOKEN_RE.findall(text or "")]

def split_into_chunks(text: str) -> List[str]:
    text = (text or "").replace("\r\n", "\n")
    parts = [p.strip() for p in re.split(r"\n\s*\n", text) if p.strip()]
    chunks = []
    buf = ""
    for p in parts:
        if len(buf) + len(p) + 2 <= CHUNK_MAX_CHARS:
            buf = (buf + "\n\n" + p).strip() if buf else p
        else:
            if len(buf) >= CHUNK_MIN_CHARS:
                chunks.append(buf.strip())
                buf = p
            else:
                buf = (buf + "\n\n" + p).strip() if buf else p
                if len(buf) >= CHUNK_MAX_CHARS:
                    chunks.append(buf.strip())
                    buf = ""
    if buf.strip():
        chunks.append(buf.strip())
    return [c for c in chunks if len(c) >= CHUNK_MIN_CHARS or len(chunks) == 1]

def is_mail_like_source(file_name: str) -> bool:
    if not file_name:
        return False
    n = file_name.lower()
    if n.endswith(".msg"):
        return True
    # cheap heuristics: many corp mail exports begin with AW_/RE_/WG_
    for pat in MAIL_SOURCE_NAME_PATTERNS:
        if re.search(pat, n, flags=re.I):
            return True
    return False

# -------------------------
# KB Readers (graceful)
# -------------------------
def read_txt(p: Path) -> str:
    return p.read_text(encoding="utf-8", errors="ignore")

def read_docx(p: Path) -> str:
    try:
        from docx import Document as DocxDocument
    except Exception:
        return ""
    try:
        doc = DocxDocument(str(p))
        paras = [clean_ws(par.text) for par in doc.paragraphs if clean_ws(par.text)]
        tables = []
        for t in doc.tables:
            for row in t.rows:
                cells = [clean_ws(c.text) for c in row.cells]
                if any(cells):
                    tables.append(" | ".join(cells))
        return clean_ws("\n".join(paras + tables))
    except Exception:
        return ""

def read_pdf(p: Path) -> str:
    try:
        import pdfplumber
        out = []
        with pdfplumber.open(str(p)) as pdf:
            for page in pdf.pages:
                txt = page.extract_text() or ""
                if txt.strip():
                    out.append(txt)
        return clean_ws("\n".join(out))
    except Exception:
        pass

    try:
        from pypdf import PdfReader
    except Exception:
        return ""
    try:
        r = PdfReader(str(p))
        out = []
        for pg in r.pages:
            try:
                out.append(pg.extract_text() or "")
            except Exception:
                pass
        return clean_ws("\n".join(out))
    except Exception:
        return ""

def read_xlsx(p: Path) -> str:
    try:
        import openpyxl
    except Exception:
        return ""
    try:
        wb = openpyxl.load_workbook(str(p), data_only=True, read_only=True)
        out = []
        for ws in wb.worksheets:
            out.append(f"Sheet: {ws.title}")
            max_rows = min(ws.max_row or 0, 200)
            max_cols = min(ws.max_column or 0, 25)
            for r in range(1, max_rows + 1):
                row_vals = []
                for c in range(1, max_cols + 1):
                    v = ws.cell(row=r, column=c).value
                    row_vals.append("" if v is None else str(v))
                if any(cell.strip() for cell in row_vals):
                    out.append(" | ".join(clean_ws(x) for x in row_vals))
        return clean_ws("\n".join(out))
    except Exception:
        return ""

def extract_text_from_file(p: Path) -> str:
    ext = p.suffix.lower()
    if ext == ".txt":
        return clean_ws(read_txt(p))
    if ext == ".docx":
        return clean_ws(read_docx(p))
    if ext == ".pdf":
        return clean_ws(read_pdf(p))
    if ext == ".xlsx":
        return clean_ws(read_xlsx(p))
    return ""

# -------------------------
# BM25-ish index
# -------------------------
@dataclass
class Chunk:
    file_name: str
    chunk_id: int
    text: str
    tokens: List[str]
    tf: Dict[str, int]
    length: int

class BM25Index:
    def __init__(self, chunks: List[Chunk]):
        self.chunks = chunks
        self.N = len(chunks)
        self.avgdl = (sum(c.length for c in chunks) / self.N) if self.N else 1.0
        self.df: Dict[str, int] = {}
        for c in chunks:
            for term in set(c.tokens):
                self.df[term] = self.df.get(term, 0) + 1

    def idf(self, term: str) -> float:
        n = self.df.get(term, 0)
        return math.log(1 + (self.N - n + 0.5) / (n + 0.5)) if self.N else 0.0

    def score(self, query_tokens: List[str], chunk: Chunk, k1: float = 1.4, b: float = 0.75) -> float:
        score = 0.0
        dl = chunk.length
        for t in query_tokens:
            if t not in chunk.tf:
                continue
            f = chunk.tf[t]
            denom = f + k1 * (1 - b + b * dl / self.avgdl)
            score += self.idf(t) * (f * (k1 + 1) / (denom + 1e-9))
        return score

    def search(self, query: str, top_k: int = 8) -> List[Chunk]:
        qt = tokenize(query)
        if not qt:
            return []
        scored = []
        for c in self.chunks:
            s = self.score(qt, c)
            if s > 0:
                scored.append((s, c))
        scored.sort(key=lambda x: x[0], reverse=True)
        return [c for _, c in scored[:top_k]]

def load_kb_build_index(kb_dir: str) -> BM25Index:
    base = Path(kb_dir)
    if not base.exists() or not base.is_dir():
        raise SystemExit(f"KB_DIR not found or not a folder: {kb_dir}")

    files = [p for p in base.rglob("*") if p.is_file() and p.suffix.lower() in SUPPORTED_EXTS]
    if not files:
        raise SystemExit(f"No supported KB files found in: {kb_dir}")

    chunks: List[Chunk] = []
    for p in sorted(files):
        try:
            txt = extract_text_from_file(p)
            if not txt:
                continue
            for i, ch in enumerate(split_into_chunks(txt)):
                toks = tokenize(ch)
                tf: Dict[str, int] = {}
                for t in toks:
                    tf[t] = tf.get(t, 0) + 1
                chunks.append(
                    Chunk(
                        file_name=p.name,
                        chunk_id=i,
                        text=ch,
                        tokens=toks,
                        tf=tf,
                        length=len(toks),
                    )
                )
        except Exception:
            continue

    if not chunks:
        raise SystemExit("KB files found, but no extractable text (missing readers or scanned PDFs).")
    return BM25Index(chunks)

# -------------------------
# Intent detection (bilingual templates)
# -------------------------
INTENT_RULES = [
    ("saq", re.compile(r"\bSAQ\b|\bSupplierAssurance\b|\bDrive\s+Sustainability\b", re.I)),
    ("green_electricity", re.compile(r"\bgreen\s+electricity\b|\berenewable\s+electricity\b|\brenewable\s+energies\b|\bGr[üu]nstrom\b", re.I)),
    ("co2_2039", re.compile(r"\b2039\b|\bCO2\b|\bCO-?neutral\b|\bnet\s*zero\b|\bAmbition\s*2039\b", re.I)),
    ("premises_sheet", re.compile(r"\bPr[äa]missenblatt\b|\bPremises\b|\bPremises\s+sheet\b|\bunterschrieben\b|\bsigned\b", re.I)),
    ("contract_attachment", re.compile(r"\bvertrag\b|\bcontract\b|\banh[aä]ng(en|t)\b|\bappend\b|\bwirksam\b|\bbinding\b", re.I)),
]

def detect_intents(text: str) -> List[str]:
    hits = []
    for name, rx in INTENT_RULES:
        if rx.search(text or ""):
            hits.append(name)
    return hits or ["general"]

def _bullets(lines: List[str], lang: str) -> str:
    # same bullet style for both
    return "\n".join([f"- {ln}" for ln in lines if ln.strip()])

def build_bilingual_reply(sender_first: str, user_first: str, intent_list: List[str],
                         retrieved_chunks: List[Chunk]) -> Tuple[str, List[str]]:
    """
    Returns (plain_text_reply, sources_used)
    - Sources and extracts: document-only (no mail-like files)
    """
    # Filter chunks for citations/extracts
    chunks_for_citation = retrieved_chunks
    if EXCLUDE_MAIL_SOURCES:
        chunks_for_citation = [c for c in retrieved_chunks if not is_mail_like_source(c.file_name)]

    # sources used
    sources = []
    for c in chunks_for_citation:
        if c.file_name not in sources:
            sources.append(c.file_name)
    sources_used = sources[:6]

    # short extracts (document-only)
    support_lines = []
    for c in chunks_for_citation[:5]:
        t = clean_ws(c.text)
        sents = re.split(r"(?<=[.!?])\s+", t)
        snippet = " ".join(sents[:2]).strip()
        if snippet and snippet not in support_lines:
            support_lines.append(snippet)

    multi = len([i for i in intent_list if i != "general"]) > 1

    # -------- German section
    de = []
    de.append(f"Hallo {sender_first},")
    de.append("")

    def add_de_section(title: str, lines: List[str]):
        if multi:
            de.append(title)
        de.append(_bullets(lines, "de"))
        de.append("")

    if "saq" in intent_list:
        add_de_section("SAQ / Nachhaltigkeitsbewertung", [
            "Bitte füllen Sie den aktuellen Sustainability Assessment Questionnaire (SAQ) auf der relevanten Plattform für den geplanten Produktionsstandort vor der Vergabe aus.",
            "Falls bereits erfolgt: Bitte bestätigen Sie den Standort und den Abschlussstatus."
        ])
    if "green_electricity" in intent_list:
        add_de_section("Grüner Strom", [
            "Bitte stellen Sie sicher, dass für die relevanten Produktionsprozesse (Tier 1) Strom aus erneuerbaren Energien eingesetzt wird – gemäß dem in den internen Dokumenten referenzierten Standard.",
            "Bei Standortwechsel oder fehlendem Ergebnis für den geplanten Standort bitte den verantwortlichen Einkauf umgehend informieren."
        ])
    if "co2_2039" in intent_list:
        add_de_section("CO2-Neutralität / Zieljahr 2039", [
            "Erwartet wird CO2-neutrale Produktion entlang der Wertschöpfungsstufen bis zum Zieltermin – einschließlich vorgelagerter Lieferkette, sofern anwendbar.",
            "Sollten Abweichungen oder zusätzliche Kostentreiber erwartet werden, bitte transparent machen und die Annahmen erläutern."
        ])
    if "premises_sheet" in intent_list:
        add_de_section("Prämissenblatt / Unterschrift", [
            "Bitte senden Sie die unterschriebenen Nachhaltigkeitsprämissen/Prämissenblätter für den relevanten Umfang, damit wir die nächsten Schritte einleiten können.",
            "Bei mehreren Umfängen bitte kurz zuordnen, welches Dokument zu welchem Umfang gehört."
        ])
    if "contract_attachment" in intent_list:
        add_de_section("Vertragliche Wirksamkeit / Anhänge", [
            "Bitte bestätigen Sie, welche Dokumente dem Liefervertrag tatsächlich angehängt werden sollen (nicht nur den Anfrageunterlagen), um die Wirksamkeit sicherzustellen.",
            "Gerne können wir den Zielprozess abstimmen (technische Anforderungen vs. Prämissen), um Informationslücken zu vermeiden."
        ])

    if intent_list == ["general"]:
        de.append("Danke für Ihre Nachricht. Basierend auf den internen Dokumenten sind die relevanten Punkte:")
        de.append("")
        if support_lines:
            de.append(_bullets(support_lines[:5], "de"))
            de.append("")
        else:
            de.append("Aktuell finde ich dazu keine passende Passage in den verfügbaren internen Dokumenten.")
            de.append("")

    if support_lines:
        de.append("Relevante Referenzen (Auszüge):")
        de.append(_bullets(support_lines[:4], "de"))
        de.append("")

    if not chunks_for_citation:
        de.append("Damit ich korrekt zuordnen kann, kurze Rückfragen:")
        de.append(_bullets(["Um welchen konkreten Umfang/Projekt geht es?", "Welcher Produktionsstandort ist geplant?"], "de"))
        de.append("")

    if sources_used:
        de.append("Quellen (intern, Dokumente): " + "; ".join(sources_used))
    else:
        de.append("Quellen (intern, Dokumente): (keine passenden Dokumente gefunden)")
    de.append("")
    de.append("Mit freundlichen Grüßen")
    de.append(user_first)

    # -------- English section
    en = []
    en.append("")
    en.append("—")
    en.append("")
    en.append(f"Hello {sender_first},")
    en.append("")

    def add_en_section(title: str, lines: List[str]):
        if multi:
            en.append(title)
        en.append(_bullets(lines, "en"))
        en.append("")

    if "saq" in intent_list:
        add_en_section("SAQ / Sustainability assessment", [
            "Please complete the latest Sustainability Assessment Questionnaire (SAQ) on the relevant platform for the planned production site before awarding.",
            "If already completed: please confirm the site and completion status."
        ])
    if "green_electricity" in intent_list:
        add_en_section("Green electricity", [
            "Please ensure electricity from renewable sources is used for the relevant production processes (Tier 1), in line with the internal standard referenced in our documents.",
            "If the production site changes or there is no result for the planned site, please inform the responsible purchaser immediately."
        ])
    if "co2_2039" in intent_list:
        add_en_section("CO2-neutral / 2039 target", [
            "The expectation is CO2-neutral production across the value creation stages by the target date, including upstream supply chain where applicable.",
            "If you foresee deviations or additional cost drivers, please make them transparent and describe the underlying assumptions."
        ])
    if "premises_sheet" in intent_list:
        add_en_section("Premises sheet / signature", [
            "Please send the signed sustainability premises/premises sheet(s) for the relevant scope so we can proceed with the next steps.",
            "If multiple scopes are involved, please clarify which document corresponds to which scope."
        ])
    if "contract_attachment" in intent_list:
        add_en_section("Contract attachment / enforceability", [
            "Please confirm which documents are intended to be attached to the supplier contract (not only to inquiry documents) to ensure enforceability.",
            "If useful, we can align on the clean process (technical requirements vs premises) to avoid information gaps."
        ])

    if intent_list == ["general"]:
        en.append("Thanks for your message. Based on our internal documents, the relevant points are:")
        en.append("")
        if support_lines:
            en.append(_bullets(support_lines[:5], "en"))
            en.append("")
        else:
            en.append("At the moment I cannot find a matching passage in the available internal documents.")
            en.append("")

    if support_lines:
        en.append("Relevant references (extracts):")
        en.append(_bullets(support_lines[:4], "en"))
        en.append("")

    if not chunks_for_citation:
        en.append("To proceed, could you confirm:")
        en.append(_bullets(["Which exact scope/project this refers to?", "Which production site is planned?"], "en"))
        en.append("")

    if sources_used:
        en.append("Sources (internal, documents): " + "; ".join(sources_used))
    else:
        en.append("Sources (internal, documents): (no matching documents found)")
    en.append("")
    en.append("Best regards,")
    en.append(user_first)

    full = "\n".join(de + en).strip()
    return full, sources_used

def format_text_to_outlook_html(text: str) -> str:
    text = (text or "").replace("\r\n", "\n").strip()
    if not text:
        return "<p></p>"

    blocks = re.split(r"\n\s*\n", text)
    html_parts = []

    for block in blocks:
        lines = [ln.rstrip() for ln in block.split("\n") if ln.strip()]
        if not lines:
            continue

        if all(ln.strip().startswith("- ") for ln in lines):
            html_parts.append("<ul>")
            for ln in lines:
                html_parts.append(f"<li>{html_escape(ln.strip()[2:].strip())}</li>")
            html_parts.append("</ul>")
        else:
            para = "<br>".join(html_escape(ln) for ln in lines)
            html_parts.append(f"<p>{para}</p>")

    return "\n".join(html_parts)

# -------------------------
# Main
# -------------------------
def main():
    time.sleep(STARTUP_DELAY_SEC)

    print("Loading KB from:", KB_DIR)
    index = load_kb_build_index(KB_DIR)
    print("KB loaded:", len(index.chunks), "chunks")

    folder, store_name, folder_name = get_target_folder()
    print(f"Mailbox={store_name} | Folder={folder_name}")

    items = folder.Items
    items.Sort("[ReceivedTime]", True)

    drafted = 0
    checked = 0

    user_first = first_name_from_email(TARGET_MAILBOX) if SIGN_FIRSTNAME_FROM_MAILBOX else FALLBACK_SIGN_NAME

    for mail in items:
        checked += 1
        if checked > SCAN_LIMIT:
            break
        if drafted >= PROCESS_PER_RUN:
            break

        try:
            if getattr(mail, "Class", None) != 43:
                continue

            if PROCESSED_CATEGORY.lower() in (mail.Categories or "").lower():
                continue

            if REQUIRE_UNREAD and not mail.UnRead:
                continue

            subject = mail.Subject or ""
            if not is_strict_subject(subject):
                continue

            sender = get_sender_smtp(mail)
            sender_first = first_name_from_email(sender)

            body_text = clean_html_to_text(mail.HTMLBody or "") or clean_ws(getattr(mail, "Body", "") or "")

            query = f"{subject}\n{body_text}"
            intents = detect_intents(query)

            top_chunks = index.search(query, top_k=TOP_K_CHUNKS)

            reply_text, sources_used = build_bilingual_reply(
                sender_first=sender_first,
                user_first=user_first,
                intent_list=intents,
                retrieved_chunks=top_chunks,
            )

            html_reply = format_text_to_outlook_html(reply_text)

            reply = mail.Reply()
            reply.HTMLBody = f"<div>{html_reply}</div><hr>" + reply.HTMLBody
            reply.Save()

            add_processed_category(mail)
            drafted += 1
            print("Draft created:", subject, "| intents:", ",".join(intents), "| doc-sources:", len(sources_used))

        except Exception as e:
            print("Mail error:", getattr(mail, "Subject", "<no subject>"), "-", e)

    print(f"Done. Checked={checked}, Drafted={drafted}")

if __name__ == "__main__":
    main()
