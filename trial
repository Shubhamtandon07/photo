# -*- coding: utf-8 -*-
"""
Outlook -> Azure OpenAI (genai-nexus) -> Draft reply (RUN ONCE) + optional self-notification

UPDATED FIXES (for your 401 case):
- Endpoint handling: tries BOTH variants
    1) https://genai-nexus.api.corpinter.net
    2) https://genai-nexus.api.corpinter.net/apikey/
  (some corp gateways require one or the other)
- Prints the *effective* endpoint + deployment name before running
- Optional OPENAI_LOG=debug support (set in config)
- More defensive error logging

BEHAVIOR:
- Only processes unread emails whose subject is EXACTLY "bot" (case-insensitive)
- Reads KB files from KB_DIR (.txt/.docx/.pdf/.xlsx) and picks relevant snippets
- Redacts sensitive patterns before sending to LLM and again on output
- Creates a DRAFT reply (does not send) unless AUTO_SEND=True
- Adds Outlook category "AI-Drafted" so you don’t process the same mail again
"""

import os
import re
import time
import json
import traceback
import tempfile
from datetime import datetime
from pathlib import Path
from typing import List, Tuple, Optional

import win32com.client as win32
from openai import AzureOpenAI
from docx import Document as DocxDocument
from pypdf import PdfReader
from dotenv import load_dotenv

load_dotenv()

# =========================================================
# CONFIG
# =========================================================
TARGET_MAILBOX = "shubham.tandon@mercedes-benz.com"   # Outlook store DisplayName substring match
WATCH_FOLDER_NAME = "Inbox"                          # "Inbox" or subfolder under Inbox

KB_DIR = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Test Data"

REQUIRE_UNREAD = True
AUTO_SEND = False
PROCESS_PER_RUN = 3
SCAN_LIMIT = 200
STARTUP_DELAY_SEC = 3

ALLOWED_SENDERS = set()  # empty = allow anyone

# Azure OpenAI
AZURE_API_VERSION = "2024-06-01"
AZURE_DEPLOYMENT_NAME = "gpt-4o"  # MUST be your Azure deployment name

# IMPORTANT: use the BASE first. The script will also try /apikey/ automatically if base fails.
AZURE_OPENAI_ENDPOINT_BASE = "https://genai-nexus.api.corpinter.net"

# Debug
ENABLE_OPENAI_DEBUG_LOG = False  # if True, sets OPENAI_LOG=debug

# Self notification
SELF_NOTIFY = True
SELF_NOTIFY_TO = TARGET_MAILBOX

# Retrieval limits
PROCESSED_CATEGORY = "AI-Drafted"
MAX_FILES = 6
MAX_CHARS_PER_FILE = 4000
MAX_TOTAL_CHARS = 12000
SUPPORTED_EXTS = {".txt", ".docx", ".pdf", ".xlsx"}

# =========================================================
# Redaction (BOT)
# =========================================================
REDACT_COMPANY_TERMS = [
    "Mercedes-Benz", "Mercedes Benz", "Mercedes", "Daimler", "corpinter", "Catena-X", "Catena X"
]
REDACT_PATTERNS = [
    (r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b", ""),  # emails
    (r"\bhttps?://[^\s<>()]+\b", ""),                              # URLs
    (r"\bwww\.[^\s<>()]+\b", ""),                                  # URLs
    (r"(?:(?:\+|00)\d{1,3}[\s\-]?)?(?:\(?\d{2,5}\)?[\s\-]?)?\d[\d\s\-]{6,}\d", ""),  # phones
    (
        r"\b(?:PO|PR|NCR|Ticket|Case|Req|Request|Material|Part|Supplier|Portal|Round|ID|Ref)\s*[:#]?\s*"
        r"[A-Za-z0-9\-_/]*\d[A-Za-z0-9\-_/]*\b",
        "the relevant reference"
    ),
    (r"(?i)\b(?:EUR|USD|GBP|CHF)\s*\d[\d\.\,\s]*\b", "an amount"),
    (r"\b\d[\d\.\,\s]*\s*(?:€|EUR|USD|GBP|CHF)\b", "an amount"),
    (r"\b€\s*\d[\d\.\,\s]*\b", "an amount"),
]


# =========================================================
# Helpers
# =========================================================
def clean_ws(s: str) -> str:
    return re.sub(r"\s+", " ", s or "").strip()


def safe_firstname_from_email(email: str) -> str:
    email = (email or "").strip()
    local = email.split("@", 1)[0] if "@" in email else email
    first = local.split(".", 1)[0].strip()
    if not first:
        return "Colleague"
    return first[:1].upper() + first[1:]


def strict_subject_is_bot(subject: str) -> bool:
    return (subject or "").strip().lower() == "bot"


def redact_sensitive(text: str) -> str:
    if not text:
        return ""
    t = text
    for term in REDACT_COMPANY_TERMS:
        if term:
            t = re.sub(re.escape(term), "", t, flags=re.IGNORECASE)
    for pat, repl in REDACT_PATTERNS:
        t = re.sub(pat, repl, t)

    t = re.sub(r"\s+", " ", t).strip()
    t = re.sub(r"\s+([,.;:])", r"\1", t)
    t = re.sub(r"([,.;:]){2,}", r"\1", t)
    t = re.sub(r"\(\s*\)", "", t)
    return t.strip()


def strip_redaction_tokens(text: str) -> str:
    if not text:
        return ""
    t = re.sub(r"\[REDACTED_[A-Z_]+\]", "", text)
    return clean_ws(t)


def format_outlook_html(text: str) -> str:
    """
    Convert plain text into Outlook-friendly HTML:
    - blank-line-separated blocks -> <p>
    - blocks where every line starts with '- ' -> <ul><li>..</li></ul>
    """
    text = (text or "").replace("\r\n", "\n").strip()
    if not text:
        return "<p></p>"

    from html import escape as _esc
    blocks = re.split(r"\n\s*\n", text)
    html_parts = []

    for block in blocks:
        lines = [ln.strip() for ln in block.split("\n") if ln.strip()]
        if not lines:
            continue

        if all(ln.startswith("- ") for ln in lines):
            html_parts.append("<ul>")
            for ln in lines:
                html_parts.append(f"<li>{_esc(ln[2:].strip())}</li>")
            html_parts.append("</ul>")
        else:
            para = "<br>".join(_esc(ln) for ln in lines)
            html_parts.append(f"<p>{para}</p>")

    return "\n".join(html_parts)


# =========================================================
# Azure client (tries both endpoint variants)
# =========================================================
def build_azure_client(endpoint: str) -> AzureOpenAI:
    key = os.getenv("OPENAI_API_KEY")
    if not key:
        raise SystemExit("OPENAI_API_KEY env var missing.")
    return AzureOpenAI(
        api_version=AZURE_API_VERSION,
        azure_endpoint=endpoint,
        api_key=key,
    )


def try_call_llm(prompt: str) -> Tuple[Optional[str], Optional[str]]:
    """
    Returns (answer, error_str). Tries base endpoint first, then /apikey/ variant.
    """
    endpoints_to_try = [
        AZURE_OPENAI_ENDPOINT_BASE.rstrip("/"),
        AZURE_OPENAI_ENDPOINT_BASE.rstrip("/") + "/apikey/",
    ]

    last_err = None
    for ep in endpoints_to_try:
        try:
            client = build_azure_client(ep)
            r = client.chat.completions.create(
                model=AZURE_DEPLOYMENT_NAME,
                temperature=0.1,
                messages=[
                    {
                        "role": "system",
                        "content": (
                            "Strictly use only snippets. Never invent. "
                            "Obey formatting requirements. Never output personal data, emails, phone numbers, "
                            "company names, IDs, or monetary amounts."
                        ),
                    },
                    {"role": "user", "content": prompt},
                ],
            )
            return (r.choices[0].message.content or ""), None
        except Exception as e:
            last_err = f"Endpoint={ep} -> {repr(e)}"
            # try next endpoint
            continue

    return None, last_err


# =========================================================
# KB readers
# =========================================================
def read_txt(p: Path) -> str:
    return p.read_text(encoding="utf-8", errors="ignore")


def extract_docx_tables_as_text(doc: DocxDocument) -> str:
    out = []
    for table in doc.tables:
        for row in table.rows:
            cells = [clean_ws(c.text) for c in row.cells]
            if any(cells):
                out.append(" | ".join(cells))
    return "\n".join(out)


def read_docx(p: Path) -> str:
    doc = DocxDocument(str(p))
    paras = "\n".join(clean_ws(par.text) for par in doc.paragraphs if clean_ws(par.text))
    tables = extract_docx_tables_as_text(doc)
    return clean_ws(paras + "\n" + tables)


def read_pdf(p: Path) -> str:
    out = []
    r = PdfReader(str(p))
    for pg in r.pages:
        try:
            out.append(pg.extract_text() or "")
        except Exception:
            pass
    return "\n".join(out)


def read_xlsx(p: Path) -> str:
    try:
        import openpyxl
    except Exception:
        return ""

    wb = openpyxl.load_workbook(str(p), data_only=True, read_only=True)
    out = []
    for ws in wb.worksheets:
        out.append(f"Sheet: {ws.title}")
        max_rows = min(ws.max_row or 0, 200)
        max_cols = min(ws.max_column or 0, 30)
        for r in range(1, max_rows + 1):
            row_vals = []
            for c in range(1, max_cols + 1):
                v = ws.cell(row=r, column=c).value
                row_vals.append("" if v is None else str(v))
            if any(cell.strip() for cell in row_vals):
                out.append(" | ".join(clean_ws(x) for x in row_vals))
    return "\n".join(out)


def extract_text_from_file(p: Path) -> str:
    ext = p.suffix.lower()
    if ext == ".txt":
        return clean_ws(read_txt(p))
    if ext == ".docx":
        return clean_ws(read_docx(p))
    if ext == ".pdf":
        return clean_ws(read_pdf(p))
    if ext == ".xlsx":
        return clean_ws(read_xlsx(p))
    return ""


def load_kb(dirpath: str) -> List[Tuple[str, str]]:
    base = Path(dirpath)
    if not base.exists() or not base.is_dir():
        raise SystemExit(f"KB_DIR not found or not a folder: {dirpath}")

    files = [p for p in base.rglob("*") if p.is_file() and p.suffix.lower() in SUPPORTED_EXTS]
    if not files:
        raise SystemExit(f"No supported KB files found in: {dirpath}")

    out: List[Tuple[str, str]] = []
    for p in sorted(files):
        try:
            txt = extract_text_from_file(p)
            if txt:
                out.append((p.name, txt[:MAX_CHARS_PER_FILE]))
        except Exception:
            pass

    if not out:
        raise SystemExit("KB files found, but no extractable text.")
    return out


def chunk_kb(files: List[Tuple[str, str]], chunk_size: int = 1200, overlap: int = 150) -> List[Tuple[str, str]]:
    """
    Improves retrieval: splits long docs into smaller chunks.
    """
    chunks: List[Tuple[str, str]] = []
    for name, text in files:
        t = clean_ws(text)
        if len(t) <= chunk_size:
            chunks.append((name, t))
            continue
        start = 0
        idx = 0
        while start < len(t):
            end = min(len(t), start + chunk_size)
            chunk = t[start:end]
            chunks.append((f"{Path(name).stem}__chunk{idx}{Path(name).suffix}", chunk))
            idx += 1
            if end >= len(t):
                break
            start = max(0, end - overlap)
    return chunks


# =========================================================
# Retrieval (simple lexical scoring)
# =========================================================
def pick_relevant(files: List[Tuple[str, str]], subject: str, body_text: str, max_files: int) -> List[Tuple[str, str]]:
    q = (subject + " " + body_text).lower()
    q_tokens = [t for t in re.split(r"[^a-z0-9]+", q) if t]
    q_set = set(q_tokens)

    scores = []
    for name, text in files:
        score = 0
        # filename tokens get higher weight
        for token in re.split(r"[^a-z0-9]+", Path(name).stem.lower()):
            if token and token in q:
                score += 8
        # content overlap
        tl = text.lower()
        for token in q_set:
            if token in tl:
                score += 1
        scores.append((score, name, text))

    scores.sort(reverse=True)
    picked = [(n, t) for s, n, t in scores[:max_files]]

    # enforce total char limit
    total = 0
    cut: List[Tuple[str, str]] = []
    for n, t in picked:
        if total + len(t) > MAX_TOTAL_CHARS:
            cut.append((n, t[: max(0, MAX_TOTAL_CHARS - total)]))
            break
        cut.append((n, t))
        total += len(t)
    return cut


# =========================================================
# Prompt + LLM
# =========================================================
def make_prompt(snips: List[Tuple[str, str]], subject: str, email_text: str, sender_firstname: str, your_firstname: str) -> str:
    redacted_subject = redact_sensitive(subject)
    redacted_email_text = redact_sensitive(email_text)

    redacted_snips = [(n, redact_sensitive(t)) for n, t in snips]
    block = "\n\n---\n\n".join([f"[{n}]\n{t}" for n, t in redacted_snips]) if redacted_snips else "(no snippets)"

    return f"""You MUST answer using ONLY the SNIPPETS below.
If the answer is not explicitly supported by the snippets, reply exactly:
"I don't have that information in the provided documents."

Write a short email reply (max 170 words). Be factual and professional.

Formatting requirements:
- Use paragraphs (blank lines) when the topic changes.
- If there are multiple steps or multiple items, use bullet points with "-" (dash), one item per line.
- Start with: "Hello {sender_firstname},"
- End with:
"Best regards,
{your_firstname}"

Do NOT include any personal data, email addresses, phone numbers, company names, IDs, or money amounts.
Do NOT copy/paste from snippets; paraphrase.

SNIPPETS:
{block}

EMAIL SUBJECT:
{redacted_subject}

EMAIL QUESTION (plain text):
{redacted_email_text}
"""


# =========================================================
# Outlook helpers
# =========================================================
def clean_html_to_text(html: str) -> str:
    txt = re.sub(r"<[^>]+>", " ", html or "", flags=re.S)
    return clean_ws(txt)


def get_sender_smtp(mail) -> str:
    try:
        addr = (mail.SenderEmailAddress or "").lower()
        if addr.startswith("/o="):
            ex = mail.Sender.GetExchangeUser()
            if ex:
                return (ex.PrimarySmtpAddress or "").lower()
        return addr
    except Exception:
        return (mail.SenderEmailAddress or "").lower()


def add_processed_category(mail):
    try:
        cats = mail.Categories or ""
        if PROCESSED_CATEGORY.lower() not in cats.lower():
            mail.Categories = (cats + "," + PROCESSED_CATEGORY).strip(",")
            mail.Save()
    except Exception:
        pass


def get_target_folder():
    ns = win32.Dispatch("Outlook.Application").GetNamespace("MAPI")

    target_store = None
    for st in ns.Stores:
        if TARGET_MAILBOX.lower() in (st.DisplayName or "").lower():
            target_store = st
            break

    if not target_store:
        print("Available stores (use one of these in TARGET_MAILBOX):")
        for st in ns.Stores:
            print(" -", st.DisplayName)
        raise SystemExit("Target mailbox not found.")

    inbox = target_store.GetDefaultFolder(6)  # Inbox

    if WATCH_FOLDER_NAME.lower() == "inbox":
        return inbox, target_store.DisplayName, "Inbox"

    for f in inbox.Folders:
        if (f.Name or "").lower() == WATCH_FOLDER_NAME.lower():
            return f, target_store.DisplayName, f.Name

    raise SystemExit(f"Subfolder '{WATCH_FOLDER_NAME}' not found under Inbox of {target_store.DisplayName}")


def get_account_for_mailbox(ns, mailbox_substring: str):
    try:
        for acc in ns.Session.Accounts:
            smtp = (getattr(acc, "SmtpAddress", "") or "").lower()
            if mailbox_substring.lower() in smtp or smtp in mailbox_substring.lower():
                return acc
    except Exception:
        pass
    return None


def send_self_notification(ns, from_mailbox: str, to_addr: str, orig_subject: str, requester_email: str, kb_files_used: List[str]):
    from html import escape as _esc

    requester_name = safe_firstname_from_email(requester_email)
    kb_html = "<br>".join([f"- {_esc(f)}" for f in kb_files_used]) if kb_files_used else "(none)"

    msg = ns.Application.CreateItem(0)
    msg.To = to_addr
    msg.Subject = f"Draft created (review needed): {orig_subject}"
    msg.HTMLBody = (
        f"<p>A draft reply has been created in Outlook.</p>"
        f"<ul>"
        f"<li><b>Original subject:</b> {_esc(orig_subject)}</li>"
        f"<li><b>Requester:</b> {_esc(requester_email)}</li>"
        f"</ul>"
        f"<p>Please verify the draft and then send it to <b>{_esc(requester_name)}</b>.</p>"
        f"<p><b>KB sources used (internal trace):</b><br>{kb_html}</p>"
    )

    acc = get_account_for_mailbox(ns, from_mailbox)
    if acc:
        try:
            msg.SendUsingAccount = acc
        except Exception:
            pass

    msg.Send()


# =========================================================
# Run once
# =========================================================
def run_bot_once():
    if ENABLE_OPENAI_DEBUG_LOG:
        os.environ["OPENAI_LOG"] = "debug"

    time.sleep(STARTUP_DELAY_SEC)

    print("=== CONFIG CHECK ===")
    k = os.getenv("OPENAI_API_KEY")
    print("OPENAI_API_KEY present:", bool(k), "len:", len(k) if k else 0)
    print("Azure API version:", AZURE_API_VERSION)
    print("Deployment name:", AZURE_DEPLOYMENT_NAME)
    print("Endpoint base:", AZURE_OPENAI_ENDPOINT_BASE)
    print("====================")

    print("Loading KB from:", KB_DIR)
    kb_files = load_kb(KB_DIR)
    kb_chunks = chunk_kb(kb_files, chunk_size=1200, overlap=150)
    print("KB loaded (chunks):", len(kb_chunks))

    ns = win32.Dispatch("Outlook.Application").GetNamespace("MAPI")
    folder, store_name, folder_name = get_target_folder()
    print(f"Mailbox={store_name} | Folder={folder_name}")

    allowed = {a.lower() for a in ALLOWED_SENDERS}

    items = folder.Items
    items.Sort("[ReceivedTime]", True)

    drafted = 0
    checked = 0

    your_firstname = safe_firstname_from_email(TARGET_MAILBOX)

    for mail in items:
        checked += 1
        if checked > SCAN_LIMIT:
            break
        if drafted >= PROCESS_PER_RUN:
            break

        try:
            if getattr(mail, "Class", None) != 43:
                continue

            if PROCESSED_CATEGORY.lower() in (mail.Categories or "").lower():
                continue

            if REQUIRE_UNREAD and not mail.UnRead:
                continue

            sender = get_sender_smtp(mail)
            if allowed and sender not in allowed:
                continue

            subject = mail.Subject or ""
            if not strict_subject_is_bot(subject):
                continue

            sender_firstname = safe_firstname_from_email(sender)
            body_text = clean_html_to_text(mail.HTMLBody or "")

            snips = pick_relevant(kb_chunks, subject, body_text, max_files=MAX_FILES)
            used_sources = [n for n, _ in snips]

            prompt = make_prompt(snips, subject, body_text, sender_firstname, your_firstname)

            answer, err = try_call_llm(prompt)
            if err:
                print("Mail error:", subject, "-", err)
                continue

            answer = redact_sensitive(answer or "")
            answer = strip_redaction_tokens(answer)

            html_answer = format_outlook_html(answer)

            reply = mail.Reply()
            reply.HTMLBody = f"<div>{html_answer}</div><hr>" + reply.HTMLBody

            if AUTO_SEND:
                reply.Send()
                print("Sent:", subject)
            else:
                reply.Save()
                print("Draft created:", subject)

                if SELF_NOTIFY:
                    try:
                        send_self_notification(
                            ns=ns,
                            from_mailbox=TARGET_MAILBOX,
                            to_addr=SELF_NOTIFY_TO,
                            orig_subject=subject,
                            requester_email=sender,
                            kb_files_used=used_sources,
                        )
                        print("Self-notification sent for:", subject)
                    except Exception as e:
                        print("Self-notification error:", repr(e))

            add_processed_category(mail)
            drafted += 1

        except Exception as e:
            print("Mail error:", getattr(mail, "Subject", "<no subject>"), "-", repr(e))
            # uncomment if you want full stack:
            # traceback.print_exc()

    print(f"Done. Checked={checked}, Drafted={drafted}")


if __name__ == "__main__":
    run_bot_once()
