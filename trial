# MSG -> DOCX (redacted) + attachments appended (PDF/Excel/DOCX/Images)  | Notebook-safe | Python 3.14
# -----------------------------------------------------------------------------------------------
# What you get:
# - One .docx per .msg file (subject + best-effort body from html/body/rtf)
# - Personal info redaction:
#     - emails, phones, URLs, IBAN-like, long IDs, addresses (heuristic), Outlook header lines
#     - specific first names you listed (Lisa, Dario, Tim, Daniel, Rasmus, Marvin, Victoria, Janina, Veronika, Athanasia, Alina, Anne)
# - Attachments handling:
#     - Saves attachments to a SHORT hash-based folder to avoid Windows path-length errors
#     - Appends extracted TEXT from attachments to the end of the DOCX:
#          PDF (pdfplumber), XLSX (openpyxl), DOCX (python-docx), Images (Pillow; OCR optional)
#     - If a required library is missing, that extractor is skipped (no crash)
#
# Requirements:
#   pip install -U extract-msg python-docx pdfplumber openpyxl pillow
# Optional OCR:
#   pip install pytesseract  (and install Tesseract exe separately + set path)
#
# IMPORTANT:
# - This script is designed for Jupyter notebooks: NO argparse.
# - Output run folder is unique each run: ...\_exports\msg_to_docx_redacted_YYYYMMDD_HHMMSS
# -----------------------------------------------------------------------------------------------

import os
import re
import io
import sys
import json
import hashlib
import traceback
from datetime import datetime
from pathlib import Path
from html import escape as html_escape
from typing import Optional, Tuple, List

# -----------------------------
# USER CONFIG
# -----------------------------
MSG_DIR = Path(r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Mails Rasmus")
EXPORT_ROOT = MSG_DIR / "_exports"

# If you want to limit processing:
MAX_FILES = None  # e.g. 50 or None

# Names you explicitly want removed (case-insensitive, match as whole word where possible)
EXTRA_NAME_BLOCKLIST = [
    "lisa", "dario", "tim", "daniel", "rasmus", "marvin", "victoria",
    "janina", "veronika", "athanasia", "alina", "anne"
]

# If you want to disable image OCR completely:
ENABLE_IMAGE_OCR = False  # if True requires pytesseract + Tesseract installed


# -----------------------------
# Optional dependency checks
# -----------------------------
def _try_import(name: str):
    try:
        return __import__(name)
    except Exception:
        return None

extract_msg = _try_import("extract_msg")

docx_mod = _try_import("docx")  # python-docx
pdfplumber = _try_import("pdfplumber")
openpyxl = _try_import("openpyxl")
PIL = _try_import("PIL")  # Pillow

pytesseract = _try_import("pytesseract") if ENABLE_IMAGE_OCR else None

# -----------------------------
# Logging
# -----------------------------
def now_stamp() -> str:
    return datetime.now().strftime("%Y%m%d_%H%M%S")

def log_line(log_path: Path, level: str, msg: str):
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    line = f"[{ts}] {level}: {msg}\n"
    log_path.parent.mkdir(parents=True, exist_ok=True)
    with log_path.open("a", encoding="utf-8", errors="ignore") as f:
        f.write(line)

def log_exc(log_path: Path, level: str, context: str, e: Exception):
    log_line(log_path, level, f"{context} -> {repr(e)}")
    tb = traceback.format_exc()
    log_line(log_path, level, tb)

# -----------------------------
# Path safety (fixes your 8 failing files)
# -----------------------------
def short_hash(text: str, n: int = 10) -> str:
    h = hashlib.sha1((text or "").encode("utf-8", errors="ignore")).hexdigest()
    return h[:n]

def sanitize_filename(name: str, max_len: int = 80) -> str:
    name = (name or "").strip()
    # illegal characters on Windows
    name = re.sub(r"[<>:\"/\\|?*\x00-\x1F]", "_", name)
    name = re.sub(r"\s+", " ", name).strip()
    name = name.rstrip(". ")
    if not name:
        name = "file"
    if len(name) > max_len:
        name = name[:max_len].rstrip(". ")
    return name

def ensure_dir(p: Path) -> Path:
    p.mkdir(parents=True, exist_ok=True)
    return p

def make_msg_attachment_dir(att_root: Path, msg_path: Path, idx: int) -> Path:
    # constant-length name avoids WinError 206
    base = f"{idx:04d}_{short_hash(str(msg_path), 10)}"
    return ensure_dir(att_root / base)

def safe_attachment_filename(original: str, idx: int, fallback_ext: str = ".bin") -> str:
    original = sanitize_filename(original, max_len=60)
    if "." not in original:
        original += fallback_ext
    return f"{idx:03d}_{original}"

# -----------------------------
# Text cleaning / redaction
# -----------------------------
EMAIL_RE = re.compile(r"\b[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}\b")
URL_RE = re.compile(r"\bhttps?://[^\s<>\"]+|\bwww\.[^\s<>\"]+", re.IGNORECASE)
PHONE_RE = re.compile(r"(\+?\d[\d\s()./-]{7,}\d)")
IBAN_RE = re.compile(r"\b[A-Z]{2}\d{2}[A-Z0-9]{10,30}\b")
LONG_ID_RE = re.compile(r"\b\d{6,}\b")  # registry-like, ref numbers etc.

# Remove typical Outlook header lines inside body (Von/An/Cc/Gesendet/Betreff etc)
HEADER_LINE_RE = re.compile(
    r"^(von|from|an|to|cc|gesendet|sent|betreff|subject)\s*:\s*.*$",
    re.IGNORECASE | re.MULTILINE
)

# Address-ish: very heuristic (you asked to remove addresses)
ADDRESS_HINT_RE = re.compile(
    r"\b(strasse|straÃŸe|street|road|rd\.|ave\.|avenue|platz|allee|gasse|weg|plz|postcode|postleitzahl)\b",
    re.IGNORECASE
)

def redact_names(text: str) -> str:
    # remove your explicit firstnames
    for n in EXTRA_NAME_BLOCKLIST:
        # word boundary where possible
        text = re.sub(rf"\b{re.escape(n)}\b", "[REDACTED]", text, flags=re.IGNORECASE)
    return text

def redact_sensitive(text: str) -> str:
    if not text:
        return ""
    t = text

    # remove Outlook header blocks
    t = HEADER_LINE_RE.sub("", t)

    # redact common sensitive items
    t = EMAIL_RE.sub("[REDACTED]", t)
    t = URL_RE.sub("[REDACTED]", t)
    t = IBAN_RE.sub("[REDACTED]", t)
    t = PHONE_RE.sub("[REDACTED]", t)

    # if a line looks like an address line, redact whole line
    lines = []
    for line in t.splitlines():
        if ADDRESS_HINT_RE.search(line):
            lines.append("[REDACTED]")
        else:
            lines.append(line)
    t = "\n".join(lines)

    # redact long numeric identifiers (keep shorter numbers for technical content)
    t = LONG_ID_RE.sub("[REDACTED]", t)

    # redact your specified names
    t = redact_names(t)

    # clean up repeated redactions / spaces
    t = re.sub(r"\[REDACTED\](\s*\[REDACTED\])+", "[REDACTED]", t)
    t = re.sub(r"\n{3,}", "\n\n", t).strip()
    return t

# -----------------------------
# Extract best body text from MSG
# -----------------------------
def msg_best_text(msg_obj) -> Tuple[str, str, str]:
    """
    Returns: (subject, body_text, body_source)
    body_source: 'html' | 'plain' | 'rtf' | 'fallback'
    """
    subj = (getattr(msg_obj, "subject", "") or "").strip()

    # Some extract_msg versions use different attribute names
    body_plain = (getattr(msg_obj, "body", None) or "")
    body_html = (getattr(msg_obj, "htmlBody", None) or getattr(msg_obj, "htmlbody", None) or "")
    body_rtf = (getattr(msg_obj, "rtfBody", None) or getattr(msg_obj, "rtfbody", None) or "")

    # Prefer HTML if it exists and looks meaningful
    if isinstance(body_html, (bytes, bytearray)):
        try:
            body_html = body_html.decode("utf-8", errors="ignore")
        except Exception:
            body_html = ""

    if isinstance(body_plain, (bytes, bytearray)):
        try:
            body_plain = body_plain.decode("utf-8", errors="ignore")
        except Exception:
            body_plain = ""

    if isinstance(body_rtf, (bytes, bytearray)):
        # We won't fully parse RTF here; fallback to plain if available
        try:
            body_rtf = body_rtf.decode("utf-8", errors="ignore")
        except Exception:
            body_rtf = ""

    # Basic HTML -> text strip
    def html_to_text(h: str) -> str:
        # remove script/style
        h = re.sub(r"(?is)<(script|style).*?>.*?</\1>", " ", h)
        # replace breaks
        h = re.sub(r"(?i)<br\s*/?>", "\n", h)
        h = re.sub(r"(?i)</p\s*>", "\n\n", h)
        # strip tags
        h = re.sub(r"(?s)<.*?>", " ", h)
        # unescape common entities
        h = h.replace("&nbsp;", " ").replace("&amp;", "&").replace("&lt;", "<").replace("&gt;", ">").replace("&quot;", '"')
        h = re.sub(r"[ \t]+", " ", h)
        h = re.sub(r"\n{3,}", "\n\n", h)
        return h.strip()

    if body_html and len(body_html.strip()) >= 40:
        txt = html_to_text(body_html)
        if len(txt.strip()) >= 40:
            return subj, txt, "html"

    if body_plain and len(body_plain.strip()) >= 10:
        return subj, body_plain.strip(), "plain"

    if body_rtf and len(body_rtf.strip()) >= 40:
        # very rough rtf cleanup
        txt = re.sub(r"{\\rtf1.*?", "", body_rtf, flags=re.DOTALL)
        txt = re.sub(r"\\par[d]?", "\n", txt)
        txt = re.sub(r"\\'[0-9a-fA-F]{2}", " ", txt)
        txt = re.sub(r"\\[a-zA-Z]+\d*", " ", txt)
        txt = re.sub(r"[{}]", " ", txt)
        txt = re.sub(r"\s+", " ", txt)
        txt = txt.strip()
        if len(txt) >= 40:
            return subj, txt, "rtf"

    # last resort: some versions expose "compressedRtf" etc; ignore
    return subj, "", "fallback"

# -----------------------------
# Attachment extractors
# -----------------------------
def extract_pdf_text(path: Path, log_path: Path) -> str:
    if pdfplumber is None:
        return ""
    try:
        out = []
        with pdfplumber.open(str(path)) as pdf:
            for i, page in enumerate(pdf.pages):
                try:
                    txt = page.extract_text() or ""
                except Exception:
                    txt = ""
                txt = txt.strip()
                if txt:
                    out.append(txt)
        return "\n\n".join(out).strip()
    except Exception as e:
        log_exc(log_path, "WARNING", f"PDF extract failed: {path.name}", e)
        return ""

def extract_xlsx_text(path: Path, log_path: Path, max_rows: int = 50, max_cols: int = 12) -> str:
    if openpyxl is None:
        return ""
    try:
        wb = openpyxl.load_workbook(str(path), data_only=True, read_only=True)
        parts = []
        for ws in wb.worksheets[:10]:
            parts.append(f"[Sheet: {ws.title}]")
            # read a small preview
            for r in range(1, min(max_rows, ws.max_row or 0) + 1):
                row_vals = []
                for c in range(1, min(max_cols, ws.max_column or 0) + 1):
                    v = ws.cell(row=r, column=c).value
                    if v is None:
                        row_vals.append("")
                    else:
                        row_vals.append(str(v))
                line = " | ".join(row_vals).strip()
                if line and line != "|":
                    parts.append(line)
            parts.append("")  # spacing
        return "\n".join(parts).strip()
    except Exception as e:
        log_exc(log_path, "WARNING", f"XLSX extract failed: {path.name}", e)
        return ""

def extract_docx_text(path: Path, log_path: Path) -> str:
    if docx_mod is None:
        return ""
    try:
        from docx import Document
        d = Document(str(path))
        paras = [p.text.strip() for p in d.paragraphs if p.text and p.text.strip()]
        return "\n".join(paras).strip()
    except Exception as e:
        log_exc(log_path, "WARNING", f"DOCX extract failed: {path.name}", e)
        return ""

def extract_image_text(path: Path, log_path: Path) -> str:
    # No OCR unless explicitly enabled and installed
    if PIL is None:
        return ""
    if not ENABLE_IMAGE_OCR or pytesseract is None:
        return ""  # skip silently

    try:
        from PIL import Image
        img = Image.open(str(path))
        txt = pytesseract.image_to_string(img)
        return (txt or "").strip()
    except Exception as e:
        log_exc(log_path, "WARNING", f"IMG OCR failed: {path.name}", e)
        return ""

def attachment_text_for_file(path: Path, log_path: Path) -> str:
    ext = path.suffix.lower()
    if ext == ".pdf":
        return extract_pdf_text(path, log_path)
    if ext in [".xlsx", ".xlsm", ".xltx", ".xltm"]:
        return extract_xlsx_text(path, log_path)
    if ext == ".docx":
        return extract_docx_text(path, log_path)
    if ext in [".png", ".jpg", ".jpeg", ".tif", ".tiff", ".bmp", ".webp"]:
        return extract_image_text(path, log_path)
    # ignore other types (but still list them)
    return ""

# -----------------------------
# Save attachments from MSG
# -----------------------------
def save_msg_attachments(msg_obj, msg_att_dir: Path, log_path: Path) -> List[Path]:
    saved = []
    # extract_msg provides saveAttachments() sometimes, but behavior varies.
    # We'll try safe methods in order.
    try:
        # method 1: saveAttachments(customPath=...)
        if hasattr(msg_obj, "saveAttachments"):
            msg_obj.saveAttachments(customPath=str(msg_att_dir))
            # collect what appeared
            for p in msg_att_dir.glob("*"):
                if p.is_file():
                    saved.append(p)
            if saved:
                return saved
    except Exception as e:
        log_exc(log_path, "WARNING", "saveAttachments failed", e)

    # method 2: iterate attachments if available
    atts = getattr(msg_obj, "attachments", None)
    if not atts:
        return saved

    for a_idx, att in enumerate(atts, start=1):
        try:
            # best-effort filename
            fn = getattr(att, "longFilename", None) or getattr(att, "shortFilename", None) or f"attachment_{a_idx}.bin"
            fn2 = safe_attachment_filename(str(fn), a_idx, fallback_ext=".bin")
            out_path = msg_att_dir / fn2

            # Some versions: att.save(customPath=..., customFilename=...)
            if hasattr(att, "save"):
                try:
                    att.save(customPath=str(msg_att_dir), customFilename=fn2)
                    if out_path.exists():
                        saved.append(out_path)
                        continue
                except Exception:
                    # try without customFilename
                    att.save(customPath=str(msg_att_dir))
                    # pick newest file
                    newest = max(msg_att_dir.glob("*"), key=lambda p: p.stat().st_mtime, default=None)
                    if newest and newest.is_file():
                        saved.append(newest)
                        continue

            # Some versions: att.data (bytes)
            data = getattr(att, "data", None)
            if isinstance(data, (bytes, bytearray)) and data:
                out_path.write_bytes(data)
                saved.append(out_path)
        except Exception as e:
            log_exc(log_path, "WARNING", f"attachment save failed (#{a_idx})", e)

    return saved

# -----------------------------
# DOCX writer
# -----------------------------
def write_docx(out_docx: Path, subject: str, body: str, attachments_info: str, log_path: Path):
    if docx_mod is None:
        raise RuntimeError("python-docx not installed. pip install python-docx")

    from docx import Document
    from docx.shared import Pt

    d = Document()

    d.add_heading("Email (redacted)", level=1)

    d.add_paragraph(f"Subject: {subject}".strip())

    d.add_paragraph("")
    d.add_heading("Body", level=2)

    if body.strip():
        for para in body.split("\n\n"):
            d.add_paragraph(para.strip())
    else:
        d.add_paragraph("(no usable body text extracted)")

    d.add_paragraph("")
    d.add_heading("Attachments (text extracted where possible)", level=2)

    if attachments_info.strip():
        for block in attachments_info.split("\n\n"):
            d.add_paragraph(block.strip())
    else:
        d.add_paragraph("(no attachments saved / no text extracted)")

    ensure_dir(out_docx.parent)
    d.save(str(out_docx))

# -----------------------------
# One MSG -> one DOCX
# -----------------------------
def msg_to_docx_one_file(msg_path: Path, out_docx: Path, att_root: Path, idx: int, log_path: Path):
    if extract_msg is None:
        raise RuntimeError("extract-msg not installed. pip install -U extract-msg")

    # open msg
    m = extract_msg.Message(str(msg_path))
    # some versions require .process(), some don't; guard it
    if hasattr(m, "process"):
        m.process()

    subject, body, src = msg_best_text(m)

    # redact
    subject_r = redact_sensitive(subject)
    body_r = redact_sensitive(body)

    # attachments
    msg_att_dir = make_msg_attachment_dir(att_root, msg_path, idx)
    saved_attachments = save_msg_attachments(m, msg_att_dir, log_path)

    # build attachments appendix
    appendix_blocks = []
    if saved_attachments:
        for a_idx, ap in enumerate(sorted(saved_attachments), start=1):
            try:
                txt = attachment_text_for_file(ap, log_path)
                txt_r = redact_sensitive(txt)

                # include file name + extracted text (if any)
                header = f"FILE {a_idx}: {ap.name}"
                if txt_r.strip():
                    appendix_blocks.append(header + "\n" + txt_r)
                else:
                    appendix_blocks.append(header + "\n" + "(no text extracted)")
            except Exception as e:
                log_exc(log_path, "WARNING", f"Attachment handling failed: {ap.name}", e)
                appendix_blocks.append(f"FILE {a_idx}: {ap.name}\n(no text extracted)")

    attachments_info = "\n\n".join(appendix_blocks).strip()

    # write docx
    write_docx(out_docx, subject_r, body_r, attachments_info, log_path)

# -----------------------------
# Runner
# -----------------------------
def run_all():
    run_dir = ensure_dir(EXPORT_ROOT / f"msg_to_docx_redacted_{now_stamp()}")
    log_path = run_dir / "errors.log"
    out_docs = ensure_dir(run_dir / "docx")
    att_root = ensure_dir(run_dir / "attachments_saved")

    # Show capability report
    print(f"Found .msg files in: {MSG_DIR}")
    msg_files = sorted(MSG_DIR.rglob("*.msg"))
    if MAX_FILES:
        msg_files = msg_files[:MAX_FILES]
    print("Found .msg files:", len(msg_files))
    print("Output run folder:", run_dir)

    print("Extractor availability:")
    print(f"  pdfplumber:  {'OK' if pdfplumber else 'MISSING'}")
    print(f"  openpyxl:    {'OK' if openpyxl else 'MISSING'}")
    print(f"  pillow:      {'OK' if PIL else 'MISSING'}")
    print(f"  pytesseract: {'OK' if (ENABLE_IMAGE_OCR and pytesseract) else 'MISSING (image OCR disabled)'}")

    ok = 0
    fail = 0

    for idx, p in enumerate(msg_files, start=1):
        try:
            base = sanitize_filename(p.stem, max_len=80)
            # keep output filename short too
            out_name = f"{idx:04d}_{base}_{short_hash(str(p), 8)}.docx"
            out_docx = out_docs / out_name

            msg_to_docx_one_file(p, out_docx, att_root, idx, log_path)
            ok += 1
        except Exception as e:
            fail += 1
            log_exc(log_path, "ERROR", str(p.name), e)

    print(f"Done. ok={ok} fail={fail}")
    print("See errors:", log_path)

# -----------------------------
# Execute
# -----------------------------
run_all()
