# -*- coding: utf-8 -*-
"""
Outlook -> Deterministic KB-based draft reply (NO LLM), improved retrieval + bilingual output.

Key improvements vs previous:
- Prefers "best" answer by exact/near-exact phrase matches before fallback retrieval.
- Excludes mail-chain-like KB docs by default (AW_/WG_/RE_ and/or .html/.htm).
- Always outputs German + English. Real translation uses Argos Translate if installed.
- Better greeting + closing.
- Marks original as read + sets category to prevent duplicates.
- Self-notification + 2-day Outlook Task reminder.

Python 3.14 compatible. No Azure/OpenAI calls.
"""

import os
import re
import time
from pathlib import Path
from typing import List, Tuple, Dict, Optional
from datetime import datetime, timedelta

import win32com.client as win32

# =========================
# EDIT THESE
# =========================
TARGET_MAILBOX = "shubham.tandon@mercedes-benz.com"
WATCH_FOLDER_NAME = "Inbox"

KB_DIR = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Test Data"

STRICT_SUBJECT = "bot"          # subject must be exactly this (case-insensitive)
REQUIRE_UNREAD = True
PROCESS_PER_RUN = 3
SCAN_LIMIT = 250
STARTUP_DELAY_SEC = 2

ALLOWED_SENDERS = set()         # empty = allow anyone
PROCESSED_CATEGORY = "AI-Drafted"

SELF_NOTIFY = True
SELF_NOTIFY_TO = TARGET_MAILBOX

CREATE_2DAY_TASK_REMINDER = True

# IMPORTANT: exclude mail-chain "documents" from KB retrieval
EXCLUDE_MAIL_CHAIN_DOCS = True

# If True, excludes .html/.htm from KB by default (recommended for your case)
EXCLUDE_HTML_FROM_KB = True
# =========================

SUPPORTED_EXTS = {".txt", ".docx", ".pdf", ".xlsx"} | (set() if EXCLUDE_HTML_FROM_KB else {".html", ".htm"})

MAX_DOC_CHARS = 40000
CHUNK_SIZE = 1600
CHUNK_OVERLAP = 250

TOP_K_CHUNKS = 6
TOP_K_SENTENCES = 8

# -------------------------
# Sensitive scrubbing for outbound replies
# -------------------------
EMAIL_RE = re.compile(r"\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b", re.I)
URL_RE = re.compile(r"\bhttps?://[^\s<>()]+\b", re.I)
WWW_RE = re.compile(r"\bwww\.[^\s<>()]+\b", re.I)
PHONE_RE = re.compile(r"(?:(?:\+|00)\d{1,3}[\s\-]?)?(?:\(?\d{2,5}\)?[\s\-]?)?\d[\d\s\-]{6,}\d")
ADDRESS_RE = re.compile(
    r"\b([A-ZÄÖÜ][a-zäöüß]+(?:\s[A-ZÄÖÜ][a-zäöüß]+){0,3})\s"
    r"(Straße|Strasse|Str\.|Weg|Allee|Platz|Ring|Gasse|Damm|Ufer)\s"
    r"\d{1,5}[a-zA-Z]?\b"
)
IBAN_RE = re.compile(r"\b[A-Z]{2}\d{2}[A-Z0-9]{11,30}\b")
MONEY_RE = re.compile(r"(?i)\b(?:€|EUR|USD|GBP|CHF)\s*\d[\d\.,\s]*\b|\b\d[\d\.,\s]*\s*(?:€|EUR|USD|GBP|CHF)\b")
REF_RE = re.compile(r"\b(?:PO|PR|NCR|Ticket|Case|Req|Request|Material|Part|VU|SP|ID|Ref)\s*[:#]?\s*[A-Za-z0-9\-_/]*\d[A-Za-z0-9\-_/]*\b", re.I)

NAME_COMMA_RE = re.compile(r"\b[A-ZÄÖÜ][a-zäöüß]+,\s*[A-ZÄÖÜ][a-zäöüß]+(?:\s+[A-ZÄÖÜ][a-zäöüß]+){0,2}\b")
NAME_SPACE_RE = re.compile(r"\b[A-ZÄÖÜ][a-zäöüß]{2,}\s+[A-ZÄÖÜ][a-zäöüß]{2,}\b")

HEADER_LINE_RE = re.compile(r"(?im)^\s*(von|from|an|to|cc|gesendet|sent|betreff|subject)\s*:.*$")

def clean_ws(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "")).strip()

def first_name_from_email(email: str) -> str:
    e = (email or "").strip().lower()
    if "@" not in e:
        return "there"
    local = e.split("@", 1)[0]
    first = local.split(".", 1)[0].strip()
    return (first[:1].upper() + first[1:]) if first else "there"

def is_strict_subject(subject: str) -> bool:
    return (subject or "").strip().casefold() == STRICT_SUBJECT.casefold()

def sanitize_outbound(s: str) -> str:
    if not s:
        return ""
    t = s
    t = HEADER_LINE_RE.sub("", t)
    t = EMAIL_RE.sub("", t)
    t = URL_RE.sub("", t)
    t = WWW_RE.sub("", t)
    t = PHONE_RE.sub("", t)
    t = ADDRESS_RE.sub("", t)
    t = IBAN_RE.sub("", t)
    t = MONEY_RE.sub("an amount", t)
    t = REF_RE.sub("the relevant reference", t)
    t = NAME_COMMA_RE.sub("", t)
    t = NAME_SPACE_RE.sub("", t)
    t = re.sub(r"\n{3,}", "\n\n", t)
    t = re.sub(r"[ \t]{2,}", " ", t)
    t = re.sub(r"\s+([,.;:])", r"\1", t)
    return t.strip()

# -------------------------
# Optional translation (Argos)
# -------------------------
def try_get_translator():
    """
    Returns a function translate(text, src, tgt) or None if unavailable.
    Recommended:
      pip install argostranslate
    Then install language packages once (DE<->EN), e.g.:
      python -c "from argostranslate import package, translate; \
                package.install_from_path(package.download_package('en','de'))"
    (Exact install method depends on your corporate network policies.)
    """
    try:
        from argostranslate import translate as argos_translate
    except Exception:
        return None

    def _translate(text: str, src: str, tgt: str) -> str:
        if not text.strip():
            return text
        # argos expects language codes like "en", "de"
        return argos_translate.translate(text, src, tgt)

    return _translate

TRANSLATE = try_get_translator()

# -------------------------
# KB readers (skip gracefully if libs missing)
# -------------------------
def read_txt(p: Path) -> str:
    return p.read_text(encoding="utf-8", errors="ignore")[:MAX_DOC_CHARS]

def read_docx(p: Path) -> str:
    try:
        from docx import Document
    except Exception:
        return ""
    try:
        doc = Document(str(p))
        parts = []
        for par in doc.paragraphs:
            txt = clean_ws(par.text)
            if txt:
                parts.append(txt)
        for table in doc.tables:
            for row in table.rows:
                cells = [clean_ws(c.text) for c in row.cells]
                if any(cells):
                    parts.append(" | ".join(cells))
        return ("\n".join(parts))[:MAX_DOC_CHARS]
    except Exception:
        return ""

def read_pdf(p: Path) -> str:
    # prefer pdfplumber if present
    try:
        import pdfplumber
        out = []
        with pdfplumber.open(str(p)) as pdf:
            for page in pdf.pages:
                txt = page.extract_text() or ""
                if txt.strip():
                    out.append(txt)
        return ("\n".join(out))[:MAX_DOC_CHARS]
    except Exception:
        pass

    try:
        from pypdf import PdfReader
        r = PdfReader(str(p))
        out = []
        for pg in r.pages:
            try:
                out.append(pg.extract_text() or "")
            except Exception:
                pass
        return ("\n".join(out))[:MAX_DOC_CHARS]
    except Exception:
        return ""

def read_xlsx(p: Path) -> str:
    try:
        import openpyxl
    except Exception:
        return ""
    try:
        wb = openpyxl.load_workbook(str(p), data_only=True, read_only=True)
        out = []
        for ws in wb.worksheets:
            out.append(f"Sheet: {ws.title}")
            max_rows = min(ws.max_row or 0, 250)
            max_cols = min(ws.max_column or 0, 40)
            for r in range(1, max_rows + 1):
                row_vals = []
                for c in range(1, max_cols + 1):
                    v = ws.cell(row=r, column=c).value
                    row_vals.append("" if v is None else str(v))
                if any(x.strip() for x in row_vals):
                    out.append(" | ".join(clean_ws(x) for x in row_vals))
        return ("\n".join(out))[:MAX_DOC_CHARS]
    except Exception:
        return ""

def read_html(p: Path) -> str:
    # only used if EXCLUDE_HTML_FROM_KB=False
    try:
        raw = p.read_text(encoding="utf-8", errors="ignore")
    except Exception:
        return ""
    # strip tags
    txt = re.sub(r"<[^>]+>", " ", raw, flags=re.S)
    return clean_ws(txt)[:MAX_DOC_CHARS]

def extract_text_from_file(p: Path) -> str:
    ext = p.suffix.lower()
    if ext == ".txt":
        return read_txt(p)
    if ext == ".docx":
        return read_docx(p)
    if ext == ".pdf":
        return read_pdf(p)
    if ext == ".xlsx":
        return read_xlsx(p)
    if ext in {".html", ".htm"}:
        return read_html(p)
    return ""

# -------------------------
# Excluding mail-chain KB files
# -------------------------
MAILCHAIN_PREFIXES = ("aw_", "wg_", "re_", "fw_", "fwd_", "antwort", "reply", "forward")
def is_mail_chain_filename(name: str) -> bool:
    n = (name or "").strip().lower()
    if n.startswith(MAILCHAIN_PREFIXES):
        return True
    # common patterns
    if " mail" in n or "mail_" in n or "email" in n:
        return True
    return False

# -------------------------
# Retrieval utilities
# -------------------------
WORD_RE = re.compile(r"[a-zA-ZÄÖÜäöüß0-9]+")
SENT_SPLIT_RE = re.compile(r"(?<=[.!?])\s+|\n+")

def tokenize(text: str) -> List[str]:
    return [w.lower() for w in WORD_RE.findall(text or "") if len(w) >= 2]

def chunk_text(text: str, size: int, overlap: int) -> List[str]:
    t = (text or "").strip()
    if not t:
        return []
    chunks = []
    i = 0
    n = len(t)
    while i < n:
        chunks.append(t[i:i+size])
        i += max(1, size - overlap)
    return chunks

def _term_freq(tokens: List[str]) -> Dict[str, int]:
    tf = {}
    for t in tokens:
        tf[t] = tf.get(t, 0) + 1
    return tf

def _safe_log(x: float) -> float:
    import math
    return math.log(max(x, 1.0000001))

def load_kb_chunks(kb_dir: str) -> List[Dict]:
    base = Path(kb_dir)
    if not base.exists() or not base.is_dir():
        raise SystemExit(f"KB_DIR not found or not a folder: {kb_dir}")

    files = [p for p in base.rglob("*") if p.is_file() and p.suffix.lower() in SUPPORTED_EXTS]
    if not files:
        raise SystemExit(f"No supported KB files found in: {kb_dir}")

    chunks = []
    for p in sorted(files):
        if EXCLUDE_MAIL_CHAIN_DOCS and is_mail_chain_filename(p.name):
            continue

        txt = extract_text_from_file(p)
        txt = (txt or "").strip()
        if not txt:
            continue

        for idx, ch in enumerate(chunk_text(txt, CHUNK_SIZE, CHUNK_OVERLAP)):
            toks = tokenize(ch)
            if not toks:
                continue
            chunks.append({
                "doc_name": p.name,
                "chunk_id": idx,
                "text": ch,
                "tf": _term_freq(toks),
            })

    if not chunks:
        raise SystemExit("KB loaded but produced 0 text chunks. (Missing libs or all docs excluded?)")

    # IDF
    df = {}
    for c in chunks:
        for term in set(c["tf"].keys()):
            df[term] = df.get(term, 0) + 1
    N = len(chunks)
    idf = {t: _safe_log((N + 1) / (df_t + 0.5)) for t, df_t in df.items()}

    for c in chunks:
        c["idf"] = idf

    return chunks

def score_chunk_bm25ish(query_tokens: List[str], chunk: Dict) -> float:
    tf = chunk["tf"]
    idf = chunk["idf"]
    score = 0.0
    doc_len = sum(tf.values()) + 1

    for qt in query_tokens:
        if qt in tf:
            # baseline
            score += (tf[qt] / (0.6 + doc_len)) * (idf.get(qt, 0.0) + 1.0) * 120.0

    return score

def score_chunk_exactness(query: str, chunk_text: str) -> float:
    """
    Boost if:
    - Long phrases from query appear exactly
    - Many query tokens appear in same sentence/line
    """
    q = clean_ws(query)
    t = chunk_text

    if not q or not t:
        return 0.0

    q_lower = q.lower()
    t_lower = t.lower()

    boost = 0.0

    # exact long substring
    if len(q_lower) >= 18 and q_lower in t_lower:
        boost += 500.0

    # exact phrase of 4-6 tokens
    q_tokens = tokenize(q)
    if len(q_tokens) >= 5:
        phrase = " ".join(q_tokens[:6])
        if phrase and phrase in t_lower:
            boost += 280.0

    # heading-like lines: short lines that include key tokens
    lines = [ln.strip() for ln in t.splitlines() if ln.strip()]
    keyset = set(q_tokens)
    for ln in lines[:30]:
        if 20 <= len(ln) <= 120:
            toks = set(tokenize(ln))
            overlap = len(keyset.intersection(toks))
            if overlap >= 4:
                boost += 60.0

    return boost

def retrieve_top_chunks(kb_chunks: List[Dict], query: str, k: int) -> List[Dict]:
    q_tokens = tokenize(query)
    if not q_tokens:
        return []

    scored = []
    for c in kb_chunks:
        s = score_chunk_bm25ish(q_tokens, c) + score_chunk_exactness(query, c["text"])
        if s > 0:
            scored.append((s, c))

    scored.sort(key=lambda x: x[0], reverse=True)
    return [c for _, c in scored[:k]]

def extract_best_sentences(chunks: List[Dict], query: str, max_sents: int) -> List[str]:
    q_tokens = set(tokenize(query))
    best = []

    scored = []
    for c in chunks:
        for sent in SENT_SPLIT_RE.split(c["text"]):
            s = clean_ws(sent)
            if len(s) < 25:
                continue
            toks = set(tokenize(s))
            if not toks:
                continue
            overlap = len(q_tokens.intersection(toks))
            if overlap <= 0:
                continue

            # Favor sentences with high overlap, penalize very long sentences
            score = overlap * 12.0 + (220.0 / max(40, len(s)))

            # Strong bonus if the sentence contains a long exact phrase from query
            q_clean = clean_ws(query).lower()
            if len(q_clean) >= 18 and q_clean in s.lower():
                score += 120.0

            scored.append((score, s))

    scored.sort(key=lambda x: x[0], reverse=True)

    seen = set()
    for _, s in scored:
        key = s.lower()
        if key in seen:
            continue
        seen.add(key)
        best.append(s)
        if len(best) >= max_sents:
            break

    return best

def sentences_to_structure(sentences: List[str]) -> Tuple[List[str], List[str]]:
    if not sentences:
        return [], []
    if len(sentences) >= 4:
        return sentences, []
    return [], sentences

# -------------------------
# Question vs "where to find" intent
# -------------------------
WHERE_FIND_CUES = re.compile(r"(?i)\b(where\s+can\s+i\s+find|where\s+to\s+find|which\s+document|in\s+which\s+document|wo\s+finde|wo\s+kann\s+ich\s+finden|in\s+welchem\s+dokument|wo\s+steht)\b")

# -------------------------
# Bilingual composition + real translation
# -------------------------
def translate_text(text: str, src: str, tgt: str) -> str:
    """
    If Argos available, translate.
    Else return original and mark as not translated (so you notice).
    """
    if not text.strip():
        return text
    if TRANSLATE is None:
        return text  # caller will handle labeling
    try:
        return TRANSLATE(text, src, tgt)
    except Exception:
        return text

def build_bilingual_email(
    sender_first: str,
    your_first: str,
    question_text: str,
    top_chunks: List[Dict],
    kb_doc_names: List[str]
) -> str:
    ask_where = bool(WHERE_FIND_CUES.search(question_text or ""))

    # Core content (German as base output from KB, then translate to English if possible)
    de_core_lines: List[str] = []

    if ask_where:
        de_core_lines.append("Ich habe die relevanten Informationen in folgenden Dokumenten gefunden:")
        for d in kb_doc_names[:6]:
            de_core_lines.append(f"- {d}")
        de_core_lines.append("")
        de_core_lines.append("Wenn du mir sagst, welchen Abschnitt du genau brauchst, kann ich die passende Stelle gezielt heraussuchen.")
    else:
        sents = extract_best_sentences(top_chunks, question_text, TOP_K_SENTENCES)
        bullets, paras = sentences_to_structure(sents)

        if bullets:
            de_core_lines.append("Hier ist die Antwort basierend auf den verfügbaren Dokumenten:")
            for b in bullets:
                de_core_lines.append(f"- {b}")
        elif paras:
            de_core_lines.append("Hier ist die Antwort basierend auf den verfügbaren Dokumenten:")
            de_core_lines.append("")
            de_core_lines.extend(paras)
        else:
            de_core_lines.append("Ich finde in den verfügbaren Dokumenten keine eindeutige Antwort auf diese Frage.")
            de_core_lines.append("Kannst du bitte den Begriff oder die konkrete Stelle nennen, nach der du suchst?")

        de_core_lines.append("")
        de_core_lines.append("Quellen (Dokumente):")
        for d in kb_doc_names[:6]:
            de_core_lines.append(f"- {d}")

    de_core = "\n".join(de_core_lines).strip()

    # Translate German core -> English core
    en_core = translate_text(de_core, "de", "en")
    translated_ok = (TRANSLATE is not None) and (en_core.strip() != de_core.strip())

    # Greeting + closing (both languages)
    de_mail = "\n".join([
        f"Hallo {sender_first},",
        "ich hoffe, es geht dir gut.",
        "",
        de_core,
        "",
        "Viele Grüße",
        your_first
    ]).strip()

    en_mail = "\n".join([
        f"Hello {sender_first},",
        "I hope you are doing well.",
        "",
        en_core if translated_ok else (en_core + "\n\n[Note: automatic translation is not available on this machine. Install Argos Translate for DE↔EN.]"),
        "",
        "Best regards,",
        your_first
    ]).strip()

    full = de_mail + "\n\n—\n\n" + en_mail
    return sanitize_outbound(full)

# -------------------------
# Outlook utilities
# -------------------------
def clean_html_to_text(html: str) -> str:
    txt = re.sub(r"<[^>]+>", " ", html or "", flags=re.S)
    txt = txt.replace("\xa0", " ")
    return clean_ws(txt)

def get_sender_smtp(mail) -> str:
    try:
        addr = (mail.SenderEmailAddress or "").lower()
        if addr.startswith("/o="):
            ex = mail.Sender.GetExchangeUser()
            if ex:
                return (ex.PrimarySmtpAddress or "").lower()
        return addr
    except Exception:
        return (mail.SenderEmailAddress or "").lower()

def add_processed_category(mail):
    try:
        cats = mail.Categories or ""
        if PROCESSED_CATEGORY.lower() not in cats.lower():
            mail.Categories = (cats + "," + PROCESSED_CATEGORY).strip(",")
            mail.Save()
    except Exception:
        pass

def mark_as_read(mail):
    try:
        mail.UnRead = False
        mail.Save()
    except Exception:
        pass

def get_target_folder():
    ns = win32.Dispatch("Outlook.Application").GetNamespace("MAPI")

    target_store = None
    for st in ns.Stores:
        if TARGET_MAILBOX.lower() in (st.DisplayName or "").lower():
            target_store = st
            break

    if not target_store:
        print("Available stores:")
        for st in ns.Stores:
            print(" -", st.DisplayName)
        raise SystemExit("Target mailbox not found.")

    inbox = target_store.GetDefaultFolder(6)  # Inbox

    if WATCH_FOLDER_NAME.lower() == "inbox":
        return inbox, target_store.DisplayName, "Inbox"

    for f in inbox.Folders:
        if (f.Name or "").lower() == WATCH_FOLDER_NAME.lower():
            return f, target_store.DisplayName, f.Name

    raise SystemExit(f"Subfolder '{WATCH_FOLDER_NAME}' not found under Inbox of {target_store.DisplayName}")

def get_account_for_mailbox(ns, mailbox_substring: str):
    try:
        for acc in ns.Session.Accounts:
            smtp = (getattr(acc, "SmtpAddress", "") or "").lower()
            if mailbox_substring.lower() in smtp or smtp in mailbox_substring.lower():
                return acc
    except Exception:
        pass
    return None

def send_self_notification(ns, to_addr: str, orig_subject: str, requester_email: str):
    try:
        msg = ns.Application.CreateItem(0)
        msg.To = to_addr
        msg.Subject = f"Draft created (review needed): {orig_subject}"
        msg.Body = (
            "A draft reply was created by the deterministic bot.\n\n"
            f"Original subject: {orig_subject}\n"
            f"Requester: {requester_email}\n\n"
            "Please review the draft before sending."
        )

        acc = get_account_for_mailbox(ns, TARGET_MAILBOX)
        if acc:
            try:
                msg.SendUsingAccount = acc
            except Exception:
                pass

        msg.Send()
    except Exception:
        pass

def create_2day_task_reminder(ns, subject: str, requester_email: str, store_display_name: str):
    try:
        task = ns.Application.CreateItem(3)  # olTaskItem
        due_dt = datetime.now() + timedelta(days=2)

        task.Subject = f"Send/review draft reply: {subject}"
        task.Body = (
            "A draft reply was created by the Outlook bot.\n\n"
            f"Original subject: {subject}\n"
            f"Requester: {requester_email}\n"
            f"Mailbox: {store_display_name}\n\n"
            "Action: Review the draft in Drafts and send it if correct."
        )

        task.StartDate = datetime.now().date()
        task.DueDate = due_dt.date()
        task.ReminderSet = True
        task.ReminderTime = due_dt
        task.Importance = 2
        task.Save()
    except Exception:
        pass

def text_to_outlook_html(text: str) -> str:
    t = (text or "").replace("\r\n", "\n").strip()
    if not t:
        return "<p></p>"

    blocks = re.split(r"\n\s*\n", t)
    html_parts = []

    for block in blocks:
        lines = [ln.rstrip() for ln in block.split("\n") if ln.strip()]
        if not lines:
            continue

        if all(ln.strip().startswith("- ") for ln in lines):
            html_parts.append("<ul>")
            for ln in lines:
                item = ln.strip()[2:].strip()
                html_parts.append(f"<li>{_html_escape(item)}</li>")
            html_parts.append("</ul>")
        else:
            para = "<br>".join(_html_escape(ln) for ln in lines)
            html_parts.append(f"<p>{para}</p>")

    return "\n".join(html_parts)

def _html_escape(s: str) -> str:
    return (s or "").replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")

# -------------------------
# MAIN
# -------------------------
def main():
    time.sleep(STARTUP_DELAY_SEC)

    print("=== CONFIG CHECK ===")
    print("Python:", os.sys.version.split()[0])
    print("KB_DIR:", KB_DIR)
    print("Subject gate:", STRICT_SUBJECT)
    print("Exclude mail-chain docs:", EXCLUDE_MAIL_CHAIN_DOCS)
    print("Exclude HTML from KB:", EXCLUDE_HTML_FROM_KB)
    print("Translator available (Argos):", bool(TRANSLATE))
    print("====================")

    print("Loading KB from:", KB_DIR)
    kb_chunks = load_kb_chunks(KB_DIR)
    print("KB loaded (chunks):", len(kb_chunks))

    ns = win32.Dispatch("Outlook.Application").GetNamespace("MAPI")
    folder, store_name, folder_name = get_target_folder()
    print(f"Mailbox={store_name} | Folder={folder_name}")

    allowed = {a.lower() for a in ALLOWED_SENDERS}

    items = folder.Items
    items.Sort("[ReceivedTime]", True)

    drafted = 0
    checked = 0
    your_first = first_name_from_email(TARGET_MAILBOX)

    for mail in items:
        checked += 1
        if checked > SCAN_LIMIT:
            break
        if drafted >= PROCESS_PER_RUN:
            break

        try:
            if getattr(mail, "Class", None) != 43:
                continue

            if PROCESSED_CATEGORY.lower() in (mail.Categories or "").lower():
                continue

            if REQUIRE_UNREAD and not mail.UnRead:
                continue

            sender = get_sender_smtp(mail)
            if allowed and sender not in allowed:
                continue

            subject = mail.Subject or ""
            if not is_strict_subject(subject):
                continue

            body_text = clean_html_to_text(getattr(mail, "HTMLBody", "") or "")
            if not body_text:
                body_text = clean_ws(getattr(mail, "Body", "") or "")

            query = f"{subject}\n{body_text}".strip()
            sender_first = first_name_from_email(sender)

            top_chunks = retrieve_top_chunks(kb_chunks, query, TOP_K_CHUNKS)
            kb_doc_names = []
            for c in top_chunks:
                if c["doc_name"] not in kb_doc_names:
                    kb_doc_names.append(c["doc_name"])

            answer_text = build_bilingual_email(
                sender_first=sender_first,
                your_first=your_first,
                question_text=body_text,
                top_chunks=top_chunks,
                kb_doc_names=kb_doc_names
            )

            html_answer = text_to_outlook_html(answer_text)

            reply = mail.Reply()
            reply.HTMLBody = f"<div>{html_answer}</div><hr>" + reply.HTMLBody
            reply.Save()

            print("Draft created:", subject)

            add_processed_category(mail)
            mark_as_read(mail)

            if SELF_NOTIFY:
                send_self_notification(ns, SELF_NOTIFY_TO, orig_subject=subject, requester_email=sender)

            if CREATE_2DAY_TASK_REMINDER:
                create_2day_task_reminder(ns, subject=subject, requester_email=sender, store_display_name=store_name)

            drafted += 1

        except Exception as e:
            print("Mail error:", getattr(mail, "Subject", "<no subject>"), "-", e)

    print(f"Done. Checked={checked}, Drafted={drafted}")

if __name__ == "__main__":
    main()
