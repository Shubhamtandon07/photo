# -*- coding: utf-8 -*-
"""
MSG Sanitizer (Outlook COM) - ONE OUTPUT PER .MSG

Reads .msg files using Outlook COM (no extract_msg, Python 3.14 OK)
- Extracts Subject + Body (prefers HTMLBody, fallback Body)
- Extracts attachments and appends their text (best-effort)
  - .pdf via pypdf (if installed)
  - .docx via python-docx (if installed)
  - .xlsx via openpyxl (if installed)
  - .txt via plain read
  - .png/.jpg OCR via pytesseract + pillow (if installed + tesseract present)
- Sanitizes:
  - removes header blocks (From/Von, To/An, CC, Sent/Gesendet etc.)
  - removes emails, URLs, domains, phones, IBAN, references/IDs, money, addresses
  - removes names (heuristics: greeting name, title+name, Firstname Lastname, Exchange /O=EXCH…)
  - removes signatures (VG/LG/BR/MfG/Kind regards etc.)
- Outputs exactly 1 file per input msg (HTML or TXT).
- Labels: question / answer (heuristic)

Run:
  python sanitize_msg_outlook.py
"""

import os
import re
import json
import shutil
import hashlib
import tempfile
from datetime import datetime
from pathlib import Path
from html import escape

# =========================
# EDIT THESE
# =========================
MSG_DIR = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Mails Rasmus"
OUT_DIR = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Mails Rasmus\_exports"

RECURSIVE = True
OUTPUT_FORMAT = "html"   # "html" or "txt"
SKIP_TEMP = True         # skip "~$" files etc.

MAX_BODY_CHARS = 25000
ATTACH_MAX_CHARS_EACH = 8000
ATTACH_MAX_FILES = 10

# =========================
# Optional: treat supplier words as sensitive
# If you want to KEEP supplier names, set this to False.
# =========================
REMOVE_SUPPLIER_WORDS = True
SUPPLIER_CUE_WORDS = [
    "lieferant", "lieferanten", "supplier",
    "kirchhoff", "bosch", "continental", "zf", "magna", "forvia", "faurecia"
]

# =========================
# Signature / greeting cues
# =========================
SIGNATURE_CLOSINGS = [
    "best regards", "kind regards", "regards",
    "mit freundlichen grüßen", "freundliche grüße", "viele grüße",
    "vg", "lg", "br", "mfg", "thanks and regards",
    "with best regards", "üdvözlettel"
]

GREETING_CUES = [
    "hallo", "hi", "hello", "guten morgen", "guten tag", "good morning",
    "dear", "liebe", "lieber"
]

REPLY_PREFIXES = ("re:", "aw:", "wg:", "fw:", "fwd:")

# =========================
# Regex patterns
# =========================
WS_RE = re.compile(r"\s+")
TAG_RE = re.compile(r"<[^>]+>", re.S)

EMAIL_RE = re.compile(r"\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b", re.I)
URL_RE = re.compile(r"\bhttps?://[^\s<>()]+\b", re.I)
WWW_RE = re.compile(r"\bwww\.[^\s<>()]+\b", re.I)
DOMAIN_RE = re.compile(r"\b(?:[a-z0-9-]+\.)+(?:[a-z]{2,})(?:/[^\s<>()]+)?\b", re.I)

PHONE_RE = re.compile(
    r"(?<!\w)(?:\+?\d{1,3}[\s\-\/]?)?(?:\(?\d{2,5}\)?[\s\-\/]?)?\d[\d\s\-\/]{6,}\d(?!\w)"
)
IBAN_RE = re.compile(r"\b[A-Z]{2}\d{2}[A-Z0-9]{11,30}\b", re.I)
MONEY_RE = re.compile(
    r"(?ix)"
    r"(?:\b(?:eur|usd|gbp|chf)\s*\d[\d\.,\s]*\b)|"
    r"(?:\b\d[\d\.,\s]*\s*(?:€|eur|usd|gbp|chf)\b)|"
    r"(?:\b€\s*\d[\d\.,\s]*\b)"
)

REF_RE = re.compile(
    r"(?i)\b(?:po|pr|ncr|ticket|case|req|request|material|part|supplier|portal|round|id|ref|sp\d+)\s*[:#]?\s*"
    r"[a-z0-9\-_\/]*\d[a-z0-9\-_\/]*\b"
)

ADDRESS_RE = re.compile(
    r"(?i)\b([A-ZÄÖÜ][a-zäöüß]+(?:\s[A-ZÄÖÜ][a-zäöüß]+){0,3})\s"
    r"(straße|strasse|str\.|weg|allee|platz|ring|gasse|damm|ufer)\s"
    r"\d{1,5}[a-z]?\b"
)

TITLE_NAME_RE = re.compile(
    r"(?i)\b(?:mr|mrs|ms|miss|dr|prof|herr|frau)\.?\s+"
    r"[A-ZÄÖÜ][a-zäöüß]+(?:\s+[A-ZÄÖÜ][a-zäöüß]+){0,2}\b"
)

NAME_RE = re.compile(r"\b[A-ZÄÖÜ][a-zäöüß]{2,}\s+[A-ZÄÖÜ][a-zäöüß]{2,}\b")

GREETING_NAME_RE = re.compile(
    r"(?im)^\s*(?:hallo|hi|hello|guten\s+morgen|guten\s+tag|good\s+morning|dear)\s+([^\n,]{2,40})"
)

THREAD_SEP_RE = re.compile(r"(?im)^\s*(?:von:|from:|sent:|gesendet:|an:|to:|cc:|betreff:|subject:)\s+.*$")
QUOTE_MARKERS_RE = re.compile(r"(?im)^\s*(?:-----original message-----|_{5,}|begin forwarded message:)\s*$")


def clean_ws(s: str) -> str:
    return WS_RE.sub(" ", s or "").strip()


def safe_output_name(source_path: Path) -> str:
    raw = source_path.stem
    cleaned = re.sub(r"[\\/:*?\"<>|]+", "_", raw)
    cleaned = re.sub(r"\s+", " ", cleaned).strip()
    h = hashlib.sha1(str(source_path).encode("utf-8", errors="ignore")).hexdigest()[:8]
    if len(cleaned) > 90:
        cleaned = cleaned[:90]
    if not cleaned:
        cleaned = "mail"
    ext = ".html" if OUTPUT_FORMAT.lower() == "html" else ".txt"
    return f"{cleaned}__{h}{ext}"


def html_to_text(raw: str) -> str:
    """Basic HTML->text while keeping line breaks."""
    if not raw:
        return ""
    s = raw.replace("\r\n", "\n")
    s = re.sub(r"(?i)<\s*br\s*/?\s*>", "\n", s)
    s = re.sub(r"(?i)</\s*p\s*>", "\n\n", s)
    s = re.sub(r"(?i)</\s*div\s*>", "\n", s)
    s = TAG_RE.sub(" ", s)

    lines = [WS_RE.sub(" ", ln).strip() for ln in s.split("\n")]
    text = "\n".join(lines)
    text = re.sub(r"\n{3,}", "\n\n", text).strip()
    return text


def strip_thread_headers(text: str) -> str:
    if not text:
        return ""
    lines = text.split("\n")
    out = []
    for ln in lines:
        if "mailto:" in ln.lower():
            continue
        if THREAD_SEP_RE.match(ln):
            continue
        if re.match(r"(?im)^\s*(priorität|priority)\s*:\s*.*$", ln):
            continue
        out.append(ln)

    t = "\n".join(out)
    m = QUOTE_MARKERS_RE.search(t)
    if m:
        t = t[:m.start()].strip()
    return re.sub(r"\n{3,}", "\n\n", t).strip()


def extract_useful_body(text: str) -> str:
    """
    Keep conversational content. Prefer from first greeting until signature.
    Fallback: stripped thread.
    """
    t = strip_thread_headers(text)

    if len(t) > MAX_BODY_CHARS:
        t = t[:MAX_BODY_CHARS]

    lines = t.split("\n")
    start_idx = 0
    for i, ln in enumerate(lines):
        l = ln.strip().lower()
        if any(l.startswith(gc) for gc in GREETING_CUES):
            start_idx = i
            break

    end_idx = len(lines)
    for i in range(len(lines)):
        l = lines[i].strip().lower()
        if any(l == sc or l.startswith(sc + " ") for sc in SIGNATURE_CLOSINGS):
            end_idx = i
            break
        if any(sc in l for sc in SIGNATURE_CLOSINGS):
            end_idx = i
            break

    body = "\n".join(lines[start_idx:end_idx]).strip()
    body = re.sub(r"\n{3,}", "\n\n", body).strip()

    if len(clean_ws(body)) < 30:
        fallback = strip_thread_headers(text).strip()
        return fallback[:MAX_BODY_CHARS] if len(clean_ws(fallback)) >= 30 else ""
    return body


def redact_text(text: str):
    """
    Delete sensitive info completely (no [PERSON] token).
    Returns (redacted_text, stats)
    """
    stats = {
        "emails": 0, "phones": 0, "urls": 0, "domains": 0, "iban": 0,
        "money": 0, "refs": 0, "addresses": 0, "names": 0, "companies": 0
    }
    if not text:
        return "", stats

    t = text

    if REMOVE_SUPPLIER_WORDS:
        for w in SUPPLIER_CUE_WORDS:
            if not w:
                continue
            t2, n = re.subn(rf"(?i)\b{re.escape(w)}\b", "", t)
            if n:
                stats["companies"] += n
                t = t2

    def sub_count(pattern, key):
        nonlocal t
        t2, n = pattern.subn("", t)
        if n:
            stats[key] += n
            t = t2

    sub_count(EMAIL_RE, "emails")
    sub_count(URL_RE, "urls")
    sub_count(WWW_RE, "urls")
    sub_count(IBAN_RE, "iban")
    sub_count(MONEY_RE, "money")
    sub_count(REF_RE, "refs")
    sub_count(ADDRESS_RE, "addresses")
    sub_count(PHONE_RE, "phones")

    # Domains (optional aggressive) – keep after URLs
    sub_count(DOMAIN_RE, "domains")

    # Title+Name
    t2, n = TITLE_NAME_RE.subn("", t)
    if n:
        stats["names"] += n
        t = t2

    # Greeting name (remove captured part only)
    def _strip_greeting_name(m):
        stats["names"] += 1
        return m.group(0).replace(m.group(1), "").strip()

    t = GREETING_NAME_RE.sub(_strip_greeting_name, t)

    # Firstname Lastname
    t2, n = NAME_RE.subn("", t)
    if n:
        stats["names"] += n
        t = t2

    # Exchange DN fragments
    t2, n = re.subn(r"(?i)/o=exch[^ \n]+", "", t)
    if n:
        stats["names"] += n
        t = t2

    # Final cleanup
    t = strip_thread_headers(t)
    t = re.sub(r"[ \t]+", " ", t)
    t = re.sub(r"\n[ \t]+", "\n", t)
    t = re.sub(r"\n{3,}", "\n\n", t).strip()
    t = re.sub(r"\s+([,.;:])", r"\1", t)
    t = re.sub(r"([,.;:]){2,}", r"\1", t)
    t = re.sub(r"\(\s*\)", "", t)

    return t.strip(), stats


def label_question_answer(subject: str, body: str) -> str:
    s = (subject or "").strip().lower()
    b = (body or "").strip().lower()

    if "?" in (body or ""):
        return "question"

    ask_cues = ["kannst du", "könnt ihr", "kann einer", "please", "bitte", "could you", "can you", "draufschauen", "check", "prüfen"]
    if any(x in b for x in ask_cues):
        return "question"

    answer_cues = ["danke", "unten", "anmerkungen", "hier", "wir plädieren", "folgende informationen", "as discussed", "as agreed"]
    if any(x in b for x in answer_cues):
        return "answer"

    if s.startswith(REPLY_PREFIXES):
        return "answer"

    return "question"


def try_extract_attachment_text(file_path: Path) -> str:
    """
    Best effort text extraction from attachment file.
    Missing libs => return "" (skip silently).
    """
    ext = file_path.suffix.lower()

    try:
        if ext == ".txt":
            return file_path.read_text(encoding="utf-8", errors="ignore")

        if ext == ".pdf":
            try:
                from pypdf import PdfReader
            except Exception:
                return ""
            out = []
            r = PdfReader(str(file_path))
            for pg in r.pages:
                try:
                    out.append(pg.extract_text() or "")
                except Exception:
                    pass
            return "\n".join(out)

        if ext == ".docx":
            try:
                from docx import Document
            except Exception:
                return ""
            doc = Document(str(file_path))
            paras = []
            for p in doc.paragraphs:
                t = clean_ws(p.text)
                if t:
                    paras.append(t)
            return "\n".join(paras)

        if ext == ".xlsx":
            try:
                import openpyxl
            except Exception:
                return ""
            wb = openpyxl.load_workbook(str(file_path), data_only=True, read_only=True)
            out = []
            for ws in wb.worksheets:
                out.append(f"Sheet: {ws.title}")
                max_rows = min(ws.max_row or 0, 200)
                max_cols = min(ws.max_column or 0, 30)
                for r in range(1, max_rows + 1):
                    row = []
                    for c in range(1, max_cols + 1):
                        v = ws.cell(row=r, column=c).value
                        row.append("" if v is None else str(v))
                    if any(x.strip() for x in row):
                        out.append(" | ".join(clean_ws(x) for x in row))
            return "\n".join(out)

        if ext in (".png", ".jpg", ".jpeg"):
            # OCR optional
            try:
                from PIL import Image
            except Exception:
                return ""
            try:
                import pytesseract
            except Exception:
                return ""
            try:
                img = Image.open(str(file_path))
                return pytesseract.image_to_string(img) or ""
            except Exception:
                return ""

    except Exception:
        return ""

    return ""


def format_output_html(source_name: str, label: str, subject: str, body: str, stats: dict) -> str:
    gen = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    subj_red, _ = redact_text(subject)
    body_display = body if body else "(no usable body text extracted)"
    body_display = escape(body_display).replace("\n\n", "<br><br>").replace("\n", "<br>")

    return f"""<html>
<head><meta charset="utf-8"><title>Sanitized Mail</title></head>
<body style="font-family:Segoe UI,Arial; font-size:13px; line-height:1.35; padding:16px;">
<div style="margin-bottom:12px;">
  <div><b>Source:</b> {escape(source_name)}</div>
  <div><b>Label:</b> {escape(label)}</div>
  <div><b>Generated:</b> {escape(gen)}</div>
  <div><b>Subject:</b> {escape(subj_red) if subj_red else "(empty subject)"}</div>
</div>
<hr>
<div><b>Body:</b></div>
<div style="margin-top:8px;">{body_display}</div>
<hr>
<div><b>RedactionStats:</b></div>
<pre style="background:#f6f6f6; padding:10px; border-radius:8px;">{escape(json.dumps(stats, ensure_ascii=False))}</pre>
</body>
</html>"""


def format_output_txt(source_name: str, label: str, subject: str, body: str, stats: dict) -> str:
    gen = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    subj_red, _ = redact_text(subject)
    b = body if body else "(no usable body text extracted)"
    return (
        f"Source: {source_name}\n"
        f"Label: {label}\n"
        f"Generated: {gen}\n"
        f"Subject: {subj_red}\n"
        f"--- BODY ---\n{b}\n\n"
        f"RedactionStats: {json.dumps(stats, ensure_ascii=False)}\n"
    )


def collect_msg_files(base_dir: str):
    base = Path(base_dir)
    if not base.exists():
        raise SystemExit(f"Input folder not found: {base}")

    files = []
    it = base.rglob("*.msg") if RECURSIVE else base.glob("*.msg")
    for p in it:
        if not p.is_file():
            continue
        name = (p.name or "").lower().strip()
        if SKIP_TEMP and name.startswith("~$"):
            continue
        files.append(p)
    return sorted(files)


def outlook_open_msg(path: str):
    """
    Outlook COM open .msg:
      ns.OpenSharedItem(path)
    Returns MailItem or None.
    """
    try:
        import win32com.client as win32
    except Exception as e:
        raise SystemExit("pywin32 is required for Outlook COM. Install: pip install pywin32") from e

    app = win32.Dispatch("Outlook.Application")
    ns = app.GetNamespace("MAPI")
    try:
        item = ns.OpenSharedItem(path)
        return item
    except Exception:
        return None


def get_msg_body_text(mail_item) -> str:
    """
    Prefer HTMLBody -> text conversion, fallback Body.
    Some mails might have empty body if exported weirdly.
    """
    html = ""
    body = ""
    try:
        html = getattr(mail_item, "HTMLBody", "") or ""
    except Exception:
        html = ""
    try:
        body = getattr(mail_item, "Body", "") or ""
    except Exception:
        body = ""

    if html.strip():
        return html_to_text(html)
    return body or ""


def extract_attachments_to_temp(mail_item, temp_dir: Path):
    """
    Save attachments to temp dir.
    Returns list of saved paths.
    Skips if access fails.
    """
    saved = []
    try:
        atts = mail_item.Attachments
    except Exception:
        return saved

    count = 0
    for i in range(1, getattr(atts, "Count", 0) + 1):
        if count >= ATTACH_MAX_FILES:
            break
        try:
            att = atts.Item(i)
            fname = getattr(att, "FileName", "") or f"attachment_{i}"
            # sanitize filename
            safe = re.sub(r"[\\/:*?\"<>|]+", "_", fname).strip()
            if not safe:
                safe = f"attachment_{i}"
            out_path = temp_dir / safe
            # ensure uniqueness
            if out_path.exists():
                out_path = temp_dir / f"{out_path.stem}_{i}{out_path.suffix}"
            att.SaveAsFile(str(out_path))
            saved.append(out_path)
            count += 1
        except Exception:
            continue

    return saved


def main():
    in_dir = Path(MSG_DIR)
    out_dir = Path(OUT_DIR)
    out_dir.mkdir(parents=True, exist_ok=True)

    msg_files = collect_msg_files(MSG_DIR)
    print("Input folder:", in_dir)
    print(".msg found:", len(msg_files))

    if not msg_files:
        print("No .msg files found. Verify MSG_DIR path and RECURSIVE setting.")
        return

    written = 0
    skipped = 0

    # temp for attachments extraction
    temp_root = Path(tempfile.mkdtemp(prefix="msg_sanitize_"))

    try:
        for p in msg_files:
            try:
                item = outlook_open_msg(str(p))
                if item is None:
                    skipped += 1
                    continue

                subject = ""
                try:
                    subject = getattr(item, "Subject", "") or ""
                except Exception:
                    subject = ""

                raw_text = get_msg_body_text(item)
                raw_text = raw_text.replace("\r\n", "\n")

                # Extract attachments -> append their extracted text (best effort)
                temp_dir = temp_root / (p.stem[:60] + "__" + hashlib.sha1(str(p).encode("utf-8", errors="ignore")).hexdigest()[:8])
                temp_dir.mkdir(parents=True, exist_ok=True)

                attach_paths = extract_attachments_to_temp(item, temp_dir)
                attach_blocks = []
                for ap in attach_paths:
                    txt = try_extract_attachment_text(ap)
                    txt = txt.strip()
                    if txt:
                        if len(txt) > ATTACH_MAX_CHARS_EACH:
                            txt = txt[:ATTACH_MAX_CHARS_EACH] + "…"
                        attach_blocks.append(f"[Attachment: {ap.name}]\n{txt}")

                if attach_blocks:
                    raw_text = (raw_text.strip() + "\n\n" + "\n\n".join(attach_blocks)).strip()

                useful = extract_useful_body(raw_text)
                red_body, stats = redact_text(useful)

                red_body = red_body.strip()
                if len(clean_ws(red_body)) < 30:
                    red_body = ""

                label = label_question_answer(subject, red_body)

                out_name = safe_output_name(p)
                out_path = out_dir / out_name

                if OUTPUT_FORMAT.lower() == "txt":
                    out_text = format_output_txt(p.name, label, subject, red_body, stats)
                    out_path.write_text(out_text, encoding="utf-8", errors="ignore")
                else:
                    out_html = format_output_html(p.name, label, subject, red_body, stats)
                    out_path.write_text(out_html, encoding="utf-8", errors="ignore")

                written += 1

            except Exception as e:
                skipped += 1
                print("SKIP:", p.name, "-", e)

    finally:
        # keep temp root? Usually we delete. If you want to inspect attachments, comment out next line.
        try:
            shutil.rmtree(temp_root, ignore_errors=True)
        except Exception:
            pass

    print("Done.")
    print("Written:", written)
    print("Skipped:", skipped)
    print("Output folder:", out_dir.resolve())


if __name__ == "__main__":
    main()
