# -*- coding: utf-8 -*-
import re
from pathlib import Path
import win32com.client as win32

# ===== EDIT =====
MSG_FOLDER = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Mails Rasmus"
OUT_TEXT_SUBFOLDER = "converted_text"
# ===============

def clean_filename(name: str, max_len: int = 140) -> str:
    name = name or "no_subject"
    name = re.sub(r"[\\/:*?\"<>|]+", "_", name)
    name = re.sub(r"\s+", " ", name).strip()
    return name[:max_len] if len(name) > max_len else name

def main():
    msg_folder = Path(MSG_FOLDER)
    print("MSG_FOLDER =", MSG_FOLDER)
    print("Resolved  =", msg_folder.resolve())
    print("Exists    =", msg_folder.exists(), "Is dir =", msg_folder.is_dir())

    msg_files = sorted(msg_folder.glob("*.msg"))
    print("Found .msg:", len(msg_files))
    if msg_files:
        print("First 3:", [f.name for f in msg_files[:3]])

    out_text_dir = msg_folder / OUT_TEXT_SUBFOLDER
    out_text_dir.mkdir(parents=True, exist_ok=True)
    print("Output dir:", out_text_dir.resolve())

    # Start Outlook COM
    print("Starting Outlook COM…")
    ns = win32.Dispatch("Outlook.Application").GetNamespace("MAPI")
    print("Outlook COM OK.")

    converted = 0
    failed = 0

    for i, f in enumerate(msg_files, start=1):
        try:
            print(f"[{i}/{len(msg_files)}] Opening:", f.name)
            item = ns.OpenSharedItem(str(f))

            # Basic inspection
            cls = getattr(item, "Class", None)
            msg_class = getattr(item, "MessageClass", "")
            subj = getattr(item, "Subject", "") or f.stem

            print("    Class =", cls, "| MessageClass =", msg_class, "| Subject =", subj[:60])

            # Extract body
            body = getattr(item, "Body", "") or ""
            if not body.strip():
                html = getattr(item, "HTMLBody", "") or ""
                body = re.sub(r"<[^>]+>", " ", html)
                body = re.sub(r"\s+", " ", body).strip()

            base_name = clean_filename(f.stem)
            out_txt = out_text_dir / f"{base_name}.txt"

            content = (
                f"FILE: {f.name}\n"
                f"SUBJECT: {subj}\n"
                f"MESSAGECLASS: {msg_class}\n"
                f"\n--- BODY ---\n"
                f"{body}\n"
            )

            out_txt.write_text(content, encoding="utf-8", errors="ignore")
            print("    Wrote:", out_txt.name)

            converted += 1

        except Exception as e:
            failed += 1
            print("    FAIL:", f.name, "|", repr(e))

    print("\nDone.")
    print("Converted:", converted)
    print("Failed   :", failed)
    print("Check output folder:", out_text_dir.resolve())

if __name__ == "__main__":
    main()



# -*- coding: utf-8 -*-
"""
Highlight sensitive patterns in .txt files and export as colored HTML.

Fixes:
- Safe output filenames (short + hash) to avoid Windows path/filename limits
Adds:
- Highlight for titles + names: Mr/Mrs/Ms/Dr/Herr/Frau + First Last
"""

import re
import hashlib
from pathlib import Path
from html import escape

# =========================
# EDIT THESE
# =========================
TXT_DIR = r"C:\Users\SHTANDO\OneDrive - Mercedes-Benz (corpdir.onmicrosoft.com)\DWT_MP_RM1 - Dokumente\Project Chatbot\Available data\Mails Rasmus\converted_text"
OUT_SUBFOLDER = "highlighted_html"

HIGHLIGHT_NAMES = True          # enable name highlighting
HIGHLIGHT_TITLES = True         # highlight Mr/Mrs/Herr/Frau patterns
# =========================

# ---- Patterns ----
EMAIL_RE = re.compile(r"\b[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}\b", re.I)

PHONE_RE = re.compile(
    r"(?<!\w)(?:\+?\d{1,3}[\s\-\/]?)?(?:\(?\d{2,5}\)?[\s\-\/]?)?\d{3,4}[\s\-\/]?\d{3,4}(?!\w)"
)

ADDRESS_RE = re.compile(
    r"\b([A-ZÄÖÜ][a-zäöüß]+(?:\s[A-ZÄÖÜ][a-zäöüß]+){0,3})\s"
    r"(Straße|Strasse|Str\.|Weg|Allee|Platz|Ring|Gasse|Damm|Ufer)\s"
    r"\d{1,5}[a-zA-Z]?\b"
)

NUMBER_RE = re.compile(r"\b\d+(?:[.,]\d+)?\b")

# Heuristic person name: Firstname Lastname (can miss names / false positives)
NAME_RE = re.compile(r"\b[A-ZÄÖÜ][a-zäöüß]{1,}\s[A-ZÄÖÜ][a-zäöüß]{1,}\b")

# Titles + name: Mr John Smith, Mrs. Jane Doe, Herr Max Mustermann, Frau Erika Mustermann
TITLE_NAME_RE = re.compile(
    r"\b(?:Mr|Mrs|Ms|Miss|Dr|Prof|Herr|Frau)\.?\s+[A-ZÄÖÜ][a-zäöüß]+(?:\s+[A-ZÄÖÜ][a-zäöüß]+){0,2}\b"
)

# Optional: “First Last (Company)” etc. You can extend later.


def safe_output_name(source_txt_path: Path) -> str:
    """
    Create a safe, short filename derived from the original, avoiding:
    - Windows invalid characters
    - Overly long filenames/paths
    """
    raw = source_txt_path.stem
    # Keep only safe-ish characters
    cleaned = re.sub(r"[\\/:*?\"<>|]+", "_", raw)
    cleaned = re.sub(r"\s+", " ", cleaned).strip()

    # Hash ensures uniqueness even after truncation
    h = hashlib.sha1(raw.encode("utf-8", errors="ignore")).hexdigest()[:8]

    # Truncate aggressively to avoid path issues
    cleaned = cleaned[:60] if len(cleaned) > 60 else cleaned
    if not cleaned:
        cleaned = "file"

    return f"{cleaned}__{h}.html"


def apply_highlights(text: str) -> str:
    """
    Convert plain text to HTML with colored spans.
    We collect spans, sort, drop overlaps, then render.
    """
    original = text
    hits = []

    def mark(regex, label):
        for m in regex.finditer(original):
            hits.append((m.start(), m.end(), label))

    # Order: more specific first
    mark(EMAIL_RE, "email")
    mark(PHONE_RE, "phone")
    mark(ADDRESS_RE, "address")

    if HIGHLIGHT_TITLES:
        mark(TITLE_NAME_RE, "title_name")
    if HIGHLIGHT_NAMES:
        mark(NAME_RE, "name")

    mark(NUMBER_RE, "number")

    # Sort spans by start, prefer longer if same start
    hits.sort(key=lambda x: (x[0], -(x[1] - x[0])))

    # Remove overlaps
    merged = []
    last_end = -1
    for s, e, label in hits:
        if s < last_end:
            continue
        merged.append((s, e, label))
        last_end = e

    color = {
        "email": "#fff59d",       # yellow
        "phone": "#c8e6c9",       # green
        "address": "#bbdefb",     # blue
        "title_name": "#ffccbc",  # orange-ish
        "name": "#f8bbd0",        # pink
        "number": "#eeeeee",      # gray
    }

    parts = []
    cur = 0
    for s, e, label in merged:
        parts.append(escape(original[cur:s]))
        parts.append(
            f'<span style="background:{color.get(label,"#ffffcc")}; padding:0 2px; border-radius:3px;">'
            f'{escape(original[s:e])}</span>'
        )
        cur = e
    parts.append(escape(original[cur:]))

    body_html = "".join(parts).replace("\n", "<br>\n")

    legend_bits = [
        ('Email', color["email"]),
        ('Phone', color["phone"]),
        ('Address', color["address"]),
        ('Title+Name', color["title_name"]) if HIGHLIGHT_TITLES else None,
        ('Name', color["name"]) if HIGHLIGHT_NAMES else None,
        ('Number', color["number"]),
    ]
    legend_bits = [b for b in legend_bits if b is not None]

    legend = '<div style="font-family:Segoe UI,Arial; font-size:13px; margin-bottom:12px;"><b>Legend:</b> '
    for label, c in legend_bits:
        legend += f'<span style="background:{c};padding:2px 6px;border-radius:3px;margin-left:6px;">{label}</span>'
    legend += "</div>"

    return f"""<html>
<head><meta charset="utf-8"><title>Highlighted Text</title></head>
<body style="font-family:Segoe UI,Arial; font-size:13px; line-height:1.35; padding:16px;">
{legend}
<div>{body_html}</div>
</body>
</html>"""


def main():
    base = Path(TXT_DIR)
    if not base.exists() or not base.is_dir():
        raise SystemExit(f"TXT_DIR not found or not a folder: {TXT_DIR}")

    out_dir = base / OUT_SUBFOLDER
    out_dir.mkdir(parents=True, exist_ok=True)

    txt_files = sorted(base.glob("*.txt"))
    print("Found .txt files:", len(txt_files))
    if not txt_files:
        print("No .txt files in folder.")
        return

    written = 0
    for f in txt_files:
        try:
            txt = f.read_text(encoding="utf-8", errors="ignore")
            html = apply_highlights(txt)

            out_name = safe_output_name(f)
            out_path = out_dir / out_name

            out_path.write_text(html, encoding="utf-8")
            written += 1

        except Exception as e:
            print("FAIL:", f.name, "-", e)

    print("Done. Written:", written, "HTML files")
    print("Output folder:", out_dir.resolve())


if __name__ == "__main__":
    main()
